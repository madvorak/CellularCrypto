\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{class_user_forms_1_1_adapter}{User\+Forms.\+Adapter} \\*Static class that allows to display an interactive window from a console application. }{\pageref{class_user_forms_1_1_adapter}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_utilities_1_1_all_binary_sequences}{Cellular.\+Utilities.\+All\+Binary\+Sequences} \\*Class for enumerating all binary sequences of a given length. Starting from 00...00, ending at 11...11. }{\pageref{class_cellular_1_1_utilities_1_1_all_binary_sequences}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_automata_test}{Testing.\+Automata\+Test} }{\pageref{class_testing_1_1_automata_test}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_automaton1_d}{Cellular.\+Automaton1\+D} \\*Abstract class for all 1\+D automata (binary \& others). }{\pageref{class_cellular_1_1_automaton1_d}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_automaton2_d}{Cellular.\+Automaton2\+D} \\*Abstract class for all 2\+D automata. When indexing, (\char`\"{}height first\char`\"{}) the distance from the top comes before the distance from the left border. }{\pageref{class_cellular_1_1_automaton2_d}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_binary1_d_automaton}{Cellular.\+Binary1\+D\+Automaton} \\*Class containing base-\/constructors for all binary 1\+D automata and implementation of the {\ttfamily \hyperlink{interface_cellular_1_1_i_binary_c_a}{I\+Binary\+C\+A}} interface. The state is kept in a {\ttfamily Bit\+Array}. }{\pageref{class_cellular_1_1_binary1_d_automaton}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_binary2_d_automaton}{Cellular.\+Binary2\+D\+Automaton} \\*Class containing base-\/constructors for all binary 2\+D automata and implementation of the {\ttfamily \hyperlink{interface_cellular_1_1_i_binary_c_a}{I\+Binary\+C\+A}} interface. The state is kept in an array of {\ttfamily Bit\+Array}s reprezenting rows. }{\pageref{class_cellular_1_1_binary2_d_automaton}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_binary_range_automaton}{Cellular.\+Binary\+Range\+Automaton} \\*Class representing any binary 1\+D automaton with symmetric scope. The automaton has firmly set borders. Referencing a cell beyond borders acts as referencing a dead cell. }{\pageref{class_cellular_1_1_binary_range_automaton}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_binary_range_cyclic_automaton}{Cellular.\+Binary\+Range\+Cyclic\+Automaton} \\*Class representing any binary 1\+D automaton with symmetric scope. The automaton is cyclic -\/ its edges are connected. Therefore, all positions are equivalent. }{\pageref{class_cellular_1_1_binary_range_cyclic_automaton}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_binary_range_n_test}{Testing.\+Binary\+Range\+N\+Test} \\*Simple demonstration that {\ttfamily Binary\+Range\+Automaton} can be used in a place of {\ttfamily Elementary\+Automaton}. }{\pageref{class_testing_1_1_binary_range_n_test}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_cannot_generate_exception}{Crypto.\+Cannot\+Generate\+Exception} \\*Custom exception that any key extender can throw. }{\pageref{class_crypto_1_1_cannot_generate_exception}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_cellular_automaton}{Cellular.\+Cellular\+Automaton} \\*The top class of the C\+A hierarchy. Every constructor should follow this logical order when considering its parametres\+: specification of the type (usually not needed), rule, size, initial state / rng. }{\pageref{class_cellular_1_1_cellular_automaton}}{}
\item\contentsline{section}{\hyperlink{class_program_1_1_crypto_form}{Program.\+Crypto\+Form} \\*Windows application for users who want to encrypt their data using a cellular automata based algorithm. }{\pageref{class_program_1_1_crypto_form}}{}
\item\contentsline{section}{\hyperlink{class_user_forms_1_1_demo_form}{User\+Forms.\+Demo\+Form} \\*Interactive visual demo of the Game of Life on a rectangular playground. This is not a platform for programming or serious experiments. }{\pageref{class_user_forms_1_1_demo_form}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_elementary_automaton}{Cellular.\+Elementary\+Automaton} \\*Class representing 256 elementary C\+A with firmly set borders. This specific implementation calculates every bit separately. }{\pageref{class_cellular_1_1_elementary_automaton}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_elementary_fast_automaton}{Cellular.\+Elementary\+Fast\+Automaton} \\*Class representing 256 elementary C\+A with firmly set borders. This specific implementation maps 10 cells onto 8 cells at once, so it should be faster a little. }{\pageref{class_cellular_1_1_elementary_fast_automaton}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_elementary_time_measure}{Testing.\+Elementary\+Time\+Measure} \\*Simple test of how different classes are (in)efficient for implementing elementary C\+A rules. }{\pageref{class_testing_1_1_elementary_time_measure}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_export}{Crypto.\+Export} \\*Public static class that gives access to our cryptographical tools. Can be used from any assembly. }{\pageref{class_crypto_1_1_export}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_factory}{Crypto.\+Factory} \\*\hyperlink{class_crypto_1_1_factory}{Factory} class containing methods for building cellular automata and key extenders from textual description. Sometimes used together with {\ttfamily Cellular\+Automaton.\+Tell\+Type()} resp. {\ttfamily I\+Binary\+C\+A.\+Tell\+Type()} method as a replacement for missing serialization / deserialization features. }{\pageref{class_crypto_1_1_factory}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_factory_test}{Testing.\+Factory\+Test} }{\pageref{class_testing_1_1_factory_test}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_function_testing}{Crypto.\+Function\+Testing} \\*Class for testing properties of key extending algorithms. }{\pageref{class_crypto_1_1_function_testing}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_function_tests_for_thesis}{Crypto.\+Function\+Tests\+For\+Thesis} \\*Wrapper for class {\ttfamily \hyperlink{class_crypto_1_1_function_testing}{Function\+Testing}}. It generates results in the form, which is suitable for my thesis. }{\pageref{class_crypto_1_1_function_tests_for_thesis}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_function_test_test}{Testing.\+Function\+Test\+Test} \\*Simple demonstration of utilities for C\+A. }{\pageref{class_testing_1_1_function_test_test}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_genetic_test}{Testing.\+Genetic\+Test} }{\pageref{class_testing_1_1_genetic_test}}{}
\item\contentsline{section}{\hyperlink{interface_cellular_1_1_i_binary_c_a}{Cellular.\+I\+Binary\+C\+A} \\*Common interface for all binary cellular automata. Most work with C\+A is done through this interface. Only subclasses of {\ttfamily \hyperlink{class_cellular_1_1_cellular_automaton}{Cellular\+Automaton}} are supposed to implement this interface. }{\pageref{interface_cellular_1_1_i_binary_c_a}}{}
\item\contentsline{section}{\hyperlink{interface_crypto_1_1_i_key_extender}{Crypto.\+I\+Key\+Extender} \\*Interface for all algorithms that can perform key stretching. Can be used from any assembly. }{\pageref{interface_crypto_1_1_i_key_extender}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_implementation2_test}{Testing.\+Implementation2\+Test} \\*Simple demonstration that {\ttfamily Elementary\+Automaton} and {\ttfamily Elementary\+Fast\+Automaton} do the same thing. }{\pageref{class_testing_1_1_implementation2_test}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_key_extender_abstract_d}{Crypto.\+Key\+Extender\+Abstract\+D} \\*Abstract class for all key extenders that implement \hyperlink{class_crypto_1_1_key_extender_abstract_d_ae403b92e9038b9c0bc7a21885e24ffc7}{Double\+Key()}. Method \hyperlink{class_crypto_1_1_key_extender_abstract_d_a3ec7fa96f391d840043eff0c8409d130}{Extend\+Key()} is provided (iterates \hyperlink{class_crypto_1_1_key_extender_abstract_d_ae403b92e9038b9c0bc7a21885e24ffc7}{Double\+Key()} method until we get a desired length). }{\pageref{class_crypto_1_1_key_extender_abstract_d}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_key_extender_abstract_n}{Crypto.\+Key\+Extender\+Abstract\+N} \\*Abstract class for all key extenders that implement \hyperlink{class_crypto_1_1_key_extender_abstract_n_a9df4156ad0a84730f87119e5a25cf1ef}{Extend\+Key()}. Method \hyperlink{class_crypto_1_1_key_extender_abstract_n_a57e9a8247ebde9e639c16107c2961d10}{Double\+Key()} simply calls \hyperlink{class_crypto_1_1_key_extender_abstract_n_a9df4156ad0a84730f87119e5a25cf1ef}{Extend\+Key()}. }{\pageref{class_crypto_1_1_key_extender_abstract_n}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_key_extender_cheating}{Crypto.\+Key\+Extender\+Cheating} \\*Fake key extender which only generates random long key independently of the short key. }{\pageref{class_crypto_1_1_key_extender_cheating}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_key_extender_copy}{Crypto.\+Key\+Extender\+Copy} \\*Stupid key extender which only copies the input (repeatedly). }{\pageref{class_crypto_1_1_key_extender_copy}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_key_extender_genetic}{Crypto.\+Key\+Extender\+Genetic} \\*Algorithms which runs a genetic algorithm to find the best sequence of extenders for each key. Generating the long key may take a very long time. }{\pageref{class_crypto_1_1_key_extender_genetic}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_key_extender_interlaced}{Crypto.\+Key\+Extender\+Interlaced} \\*Different linear algorithm, which uses specified number of steps of the underlying C\+A. }{\pageref{class_crypto_1_1_key_extender_interlaced}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_key_extender_simple_linear}{Crypto.\+Key\+Extender\+Simple\+Linear} \\*Simple algorithm, which uses only two steps of the underlying C\+A. }{\pageref{class_crypto_1_1_key_extender_simple_linear}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_key_extender_simple_quadratic}{Crypto.\+Key\+Extender\+Simple\+Quadratic} \\*Simple algorithm, which calls one step of the underlying C\+A for every bit to be generated. Generating the long key may take a very long time. }{\pageref{class_crypto_1_1_key_extender_simple_quadratic}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_key_extender_uncertain}{Crypto.\+Key\+Extender\+Uncertain} \\*Intelligent key extender that equalizes frequencies of 0 and 1, which may be different in the underlying C\+A. However it is not guaranteed that the long key will be generated. }{\pageref{class_crypto_1_1_key_extender_uncertain}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_main_tests}{Testing.\+Main\+Tests} \\*The most important tests (rating of key extenders) for my thesis. }{\pageref{class_testing_1_1_main_tests}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_nary1_d_automaton}{Cellular.\+Nary1\+D\+Automaton} \\*Abstract class for general 1\+D N-\/ary automata. }{\pageref{class_cellular_1_1_nary1_d_automaton}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_nary_totalistic_automaton}{Cellular.\+Nary\+Totalistic\+Automaton} \\*Class representing any n-\/ary one-\/dimensional automaton with a totalistic rule -\/ bordered variant. The new state of each cell depends on the sum of its current state and the current state of adjecent cells. }{\pageref{class_cellular_1_1_nary_totalistic_automaton}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_nary_totalistic_cyclic_automaton}{Cellular.\+Nary\+Totalistic\+Cyclic\+Automaton} \\*Class representing any N-\/ary one-\/dimensional automaton with a totalistic rule -\/ cyclic variant. The new state of each cell depends on the sum of its current state and the current state of adjecent cells. }{\pageref{class_cellular_1_1_nary_totalistic_cyclic_automaton}}{}
\item\contentsline{section}{\hyperlink{class_program}{Program} }{\pageref{class_program}}{}
\item\contentsline{section}{\hyperlink{class_program_1_1_program}{Program.\+Program} }{\pageref{class_program_1_1_program}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_randomness_testing}{Crypto.\+Randomness\+Testing} \\*Static class that contains some tests of randomness for binary sequences. }{\pageref{class_crypto_1_1_randomness_testing}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_random_test_test}{Testing.\+Random\+Test\+Test} \\*Demonstration of the implemented tests of randomness, especially the entropy test. }{\pageref{class_testing_1_1_random_test_test}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_search_longest}{Testing.\+Search\+Longest} \\*Simple demonstration of working with period lengths. }{\pageref{class_testing_1_1_search_longest}}{}
\item\contentsline{section}{\hyperlink{class_crypto_1_1_search_s_g_a}{Crypto.\+Search\+S\+G\+A} \\*Static class that can be used to pre-\/generate good key extenders for the genetic algorithm. }{\pageref{class_crypto_1_1_search_s_g_a}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_totalistic2_d_automaton}{Cellular.\+Totalistic2\+D\+Automaton} \\*Class representing a totalistic 2\+D automaton that uses Moore Neighborhood. }{\pageref{class_cellular_1_1_totalistic2_d_automaton}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_totalistic2_d_automaton_interactive}{Cellular.\+Totalistic2\+D\+Automaton\+Interactive} \\*Class representing a totalistic 2\+D automaton that uses Moore Neighborhood with enhanced functionalities. For instance, this can be used as Conway\textquotesingle{}s Game of Life automaton for interactive use (e.\+g. in Winforms). }{\pageref{class_cellular_1_1_totalistic2_d_automaton_interactive}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_totalistic_ternary_test}{Testing.\+Totalistic\+Ternary\+Test} \\*Simple demonstration of 1\+D ternary totalistic automata. }{\pageref{class_testing_1_1_totalistic_ternary_test}}{}
\item\contentsline{section}{\hyperlink{class_cellular_1_1_utilities}{Cellular.\+Utilities} \\*Static class packing a group of utilities for working with C\+A. }{\pageref{class_cellular_1_1_utilities}}{}
\item\contentsline{section}{\hyperlink{class_testing_1_1_utility_test}{Testing.\+Utility\+Test} \\*Simple demonstration of utilities for C\+A. }{\pageref{class_testing_1_1_utility_test}}{}
\end{DoxyCompactList}
