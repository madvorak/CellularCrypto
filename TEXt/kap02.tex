%%% Kapitola o šifrování

\chapter{Šifrování}

Lidé u v dávnıch dobách chtìli tajit nìkteré informace pøed lidmi, pro nì nejsou urèeny, a pøitom je doruèit lidem, kteøí se je mají dozvìdìt. Pùvodnì se k tìmto úèelùm pouívala takzvaná \textsl{staganografie}, tedy utajení samotné existence zprávy. Panovník napøíklad nechal oholit hlavu jednomu ze svıch sluhù, zprávu napsal na jeho temeno a po obnovení vlasù poslal sluhu na místo doruèení. Na druhé stranì opìt oholili hlavu sluhy a pøeèetli si tajnou zprávu. Další zpùsob steganografie je psaní zprávy neviditelnım inkoustem, kterı se stává èitelnım po zahøátí média. Nyní lze staganografii realizovat napøíklad tak, e se binárnì zakódovaná zpráva uloí do nejménì vıznamnıch bitù obrázku v poèítaèi. Okem není mono rozpoznat ádnou zmìnu, ale se znalostí toho, e se v urèitém obrázku nachází tajná zpráva, lze poèítaèovım programem onu zprávu zase snadno zobrazit. To u je pomìrnì rychlı postup.

V dnešní dobì ovšem steganografie nestaèí. Lidstvo musí pracovat s èím dál vìtším mnostvím dùvìrnıch a tajnıch informací a pøi tomto mnoství utajování zpráv se steganografické postupy stanou velmi rychle \uv{profláklé} a tím neúèinné. Proto jsou intenzivnì studovány rùzné monosti šifrování tajnıch zpráv, pøi jejich vyuití je zpráva skryta i pøed útoèníkem, kterı má pøesnou informaci o tom, kde se zpráva nachází.

\section{Základní pojmy}

Úkolem šifrování je uchovat a pøedat tajnou zprávu tak, aby ji mohl pøeèíst ten, pro koho je urèena, ale u nikdo jinı. Dále se nìkdy za cíl dává ovìøitelnost autora zprávy. Vìda zabıvající se šifrováním se nazıvá \textsl{kryptografie}. Lámáním šifer se zase zabıvá  \textsl{kryptoanalıza}.

Pùvodní èitelná zpráva se nazıvá \textsl{plaintext}. Data po zašifrování se nazıvají \textsl{ciphertext}. Pro pøevod plaintextu na ciphertext je potøeba pouít šifrovací algoritmus. Ten by mìl zároveò bıt schopen pøevést ciphertext zpìt na plaintext (tzv. dešifrování). Protoe fungování šifrovacího algoritmu se velmi snadno vyzradí, zásadní roli hraje \textsl{šifrovací klíè}, co je další informace nutná k šifrování. Pokud se jedná o \textsl{symetrickou kryptografii}, tak stejnı klíè slouí i k dešifrování. V pøípadì \textsl{asymetrické kryptografie} se pouívají dva rùzné klíèe. Šifrovací resp. dešifrovací klíè v~asymetrické kryptografii se s ohledem na jejich pouití nazıvají jako \textsl{veøejnı} resp. \textsl{tajnı} klíè.

\section{Základní vıchodiska}

Pøed zašifrováním zprávy se èasto provádí její \textsl{komprese}. To má za následek nejen úsporu pøenosového pásma a mnoství práce (èasu) šifrovacího algoritmu, ale velkou vıhodou je dosaení vıraznì rovnomìrnìjšího pravdìpodobnostního rozdìlení na prostoru plaintextù, co vıraznì komplikuje kryptoanalızu.

Jedinou známou zcela neprolomitelnou šifrovací metodou je Vernamova šifra. V binární podobì tato šifra vypadá tak, e se pouije one-time pad, co je sekvence náhodnıch bitù, kterou vlastní obì strany. Odesílatel provede operaci plaintext XOR one-time pad a pøíjemce provede operaci ciphertext XOR one-time pad, èím dostane zpìt plaintext. Problém je, e one-time pad musí bıt stejnì dlouhı jako plaintext a nelze ho pouít opakovanì. Kvùli tomu se Vernamova šifra pouívá jen pro kritické aplikace, pøed kterımi se mohou komunikující strany fyzicky setkat a pøedat si one-time pad. To znemoòuje její pouití pro bìnou internetovou komunikaci.

\section{O co nám jde}

V této práci se budeme vìnovat vytvoøení algoritmu na protahování klíèù (anglicky key stretching). Cílem je z krátkého klíèe (kterı lze napøíklad v krátkém èase pøenést pomocí RSA) vygenerovat dlouhı klíè (one-time pad, kterım lze pøeXORovat celı soubor). Je to tedy podobnı úkol jako naprogramovat \textsl{Keystream Generator}, tedy program, kterı generuje kdykoliv opakovatelnou sekvenci bitù. Jedinı rozdíl je, e my budeme dopøedu znát cílenou délku vısledného klíèe.

\section{Pseudonáhodné generátory}

Jako velmi jednoduchı Keystream Generator by se dal pouít nìjakı z generátorù pseudonáhodnıch èísel. Narozdíl od \uv{opravdovıch} generátorù náhodnıch èísel, které pouívají nìjakı fyzikální zdroj náhody (tøeba radioaktivní rozpad), jsou hodnoty vytváøené generátorem pseudonáhodnıch èísel deterministicky urèeny poèáteèní hodnotou (tzv. seed), která mùe bıt zvolena na základì krátkého klíèe.

Typickım pøíkladem mùe bıt lineární kongruenèní generátor pseudonáhodnıch èísel (LCG - Linear Congruential Generator). Ten je charakterizován rozsahem hodnot $m$, koeficientem $a$, inkrementem $c$ a poèáteèní hodnotou $X_0$. LCG provádí krok podle vzorce:
$$X_{n+1} = (aX_n + c) \mod m$$
Pro to, aby byl generátor pseudonáhodnıch èísel kvalitní, je potøeba, aby vıstupy nemìly zjevné lineární vztahy mezi sebou a mìly dlouhou periodu. Podmínky pro to, aby LCG mìl periodu délky $m$ (tj. vystøídal všechny moné hodnoty), jsou následující, viz \citep{Knuth}:
\begin{itemize}
\item $c$ a $m$ jsou nesoudìlná èísla
\item $a-1$ je dìlitelné všemi prvoèiniteli $m$
\item pokud je $m$ dìlitelné 4, je i $a-1$ dìlitelné 4
\end{itemize}
Tøetí pravidlo je velice dùleité, protoe s ohledem na vıkon programu na reálnıch procesorech se obvykle volí $m$ v hodnotì mocniny dvou\footnote{Bìnì se pouívá nastavení, kde rozsah je mocnina dvou ($m = 2^n$, kde $n$ je èíslo od 24 do 64), $c=1$, $a$ libovolné takové, e $1 \equiv a \mod 4$}.

Jako pseudonáhodnou posloupnost není dobré pouít pøímo hodnoty $X_i$. Problém je zejména vidìt tehdy, kdy $m = 2^n$. Pak se lze podívat na posledních $d$ bitù èísel $X_i$, oznaème je $Y_i = X_i \mod 2^d$. Ty tvoøí posloupnost s kratší periodou. Její pøedpis lze napsat stejnım zpùsobem, jako pøedpis pro LCG:
$$Y_{n+1} = (qY_n+r) \mod 2^d$$, kde $q = a \mod 2^d$, $r = c \mod 2^d$.

Øešením je pouití jen nìkolika poèáteèních bitù z kadého $X_i$. Pokud by se na vıstup posílala celá hodnota $X_i$, byla by èást bitù snadno pøedvídatelná. Napøíklad kadı $m$-tı bit vıstupu by pravidelnì støídal 0 a 1.

Existují i jiné generátory pseudonáhodnıch èísel, které jsou vhodnìjší pro kryptografické úèely. Ve skuteènosti není skoro ádnı rozdíl mezi Keystream Generator a generátorem pseudonáhodnıch èísel. Odlišuje je jen to, e generátory pseudonáhodnıch èísel pouívají seed menší velikosti, kdeto Keystream Generator lze inicializovat klíèem vìtší velikosti a taky udruje \uv{sloitìjší} vnitøní stav.

\section{Blokové šifry}

Blokové šifry jsou klasickım zpùsobem symetrické kryptografie, které se dnes pouívají ve vìtšinì kryptosystémù. Spoleènım znakem blokovıch šifer je, e s vyuitím šifrovacího klíèe transformují vstup pevné velikosti na vıstup stejné velikosti (jde o bloky bitù, jejich velikost je urèena ji pøi návrhu šifry). Aby bylo moné ze ciphertextu opìt získat plaintext (bloková šifra definuje, jak se stejnım klíèem provést obì zobrazení), musí bıt pro kadou hodnotu klíèe toto zobrazení bijekce mezi vstupy a vıstupy. Plaintext se rozdìlí na bloky dané velikosti, kadı z nich se zašifruje a bloky ciphertextu se zøetìzí za sebou (bloky ciphertextu jsou opìt stejnì dlouhé, tudí není potøeba jejich explicitní oddìlování). Velikost bloku mùe bıt napøíklad 128 bitù. Klíè mùe bıt vìtší i menší.

% Difuze vyjadøuje, kolik bitù na vstupu mùe ovlivnit jeden bit na vıstupu. Konfuze vyjadøuje, jak sloitı tento vztah je, viz \citep{Klima}. Difuze je obvykle dosahováno permutováním bitù. Konfuze se obvykle dosahuje pomocí nelineárních substitucí. Mnoho blokovıch cifer je zaloeno na tom, e opakovanì provádí støídavì substituci a permutaci (staèí jednoduchá transpozice). 

\subsection{Operaèní módy}

Existuje nìkolik operaèních módù blokovıch šifer. Ty popisují, jakım zpùsobem je bloková šifra zapojená pøi šifrování celé zprávy.

\newcommand{\bcmoop}[2]{
\begin{figure}[h]
\centering
\includegraphics[width=150mm, height=50mm]{#1#2.png}
\caption{#1 #2}
\label{#1#2}
\end{figure}}

\bcmoop{ECB}{encryption}
\bcmoop{ECB}{decryption}

Nejjednodušším módem je ECB (Electronic CodeBook). Ten šifruje kadı blok plaintextu pøímou aplikací blokové šifry bez jakékoliv návaznosti na ostatní bloky (zašifrování je na obrázku \ref{ECBencryption}, rozšifrování je na obrázku \ref{ECBdecryption}). Bezpeènost tohoto modu je dost slabá, protoe kdykoliv obsahuje plaintext dvojici stejnıch blokù, jsou jim odpovídající èásti ciphertextu také shodné (take po zašifrování je napøíklad moné lidskım okem rozpoznávat tvary v bitmapovıch obrázcích, které obsahují jednobarevné plochy).

\bcmoop{CBC}{encryption}
\bcmoop{CBC}{decryption}

Lepším módem je CBC (Cipher Block Chaining). Zde je kadı blok plaintextu pøed zašifrováním XORován s pøedchozím blokem ciphertextu (zašifrování je na obrázku \ref{CBCencryption}, rozšifrování je na obrázku \ref{CBCdecryption}). První plaintext je XORován s inicalizaèním vektorem. Pøi ponechání stejného plaintextu a stejného klíèe se zmìnou inicializaèního vektoru mìní celı ciphertext, co útoèníkovi komplikuje rozpoznání, kdy jsou odeslány 2 stejné zprávy. CBC má vıraznì lepší vlastnosti ne ECB, ale to neznamená, e bychom mohli pouit libovolnou blokovou šifru. Kdybychom jako blokovou šifru zvolili pouhı XOR mezi plaintextem a šifrovacím klíèem, tak by pøi CBC zapojení došlo k tomu, e kadı druhı blok zprávy by vùbec nebyl ovlivnìn klíèem (byl by to jen plaintext XOR inicializaèní vektor). Ale pøi vyuití vhodné blokové šifry (mající vysokou difuzi a konfuzi) jsou vısledky velmi dobré. Nevıhodou této metody je, e se zašifrování nedá paralelizovat (ale rozšifrování lze).

\bcmoop{PCBC}{encryption}
\bcmoop{PCBC}{decryption}

Podobnım módem je PCBC (Propagating Cipher Block Chaining). Zde se do vıpoètu následujícího bloku neposílá jen ciphertext, ale i plaintext (zašifrování je na obrázku \ref{PCBCencryption}, rozšifrování je na obrázku \ref{PCBCdecryption}). Nejsou mi známy ádné vıhody této metody ve srovnání s CBC.

\bcmoop{OFB}{encryption}
\bcmoop{OFB}{decryption}

A teï se dostáváme ke dvìma metodám, které umoòují pouít blokovou šifru jako Keystream Generator, protoe se XOR s plaintextem aplikuje zvláš a je moné ho provést a po všech vyvolání blokové šifry.

První z nich je OFB (Output Feedback). OFB nejprve pouije blokovou šifru k tomu, aby zašifrovala inicializaèní vektor pomocí klíèe. Vısledek je jednak poslán ven a dále je poslán na vstup blokové šifry. Tento blok je zase zašifrován pomocí stejného klíèe a vısledek je poslán opìt jak na vıstup, tak do další blokové šifry. Postup si lze prohlédnout na obrázku \ref{OFBencryption}. Dá se øíci, e OFB posílá na vıstup Keystream, kterı se skládá z øady $f(x), f(f(x)), f(f(f(x))), f(f(f(f(x)))), f(f(f(f(f(x))))),~...$, kde $x$ je inicializaèní vektor a funkce $f$ je ji zobrazení s konkrétním klíèem. Rozšifrování je triviální obdobou tohoto postupu. Není k nìmu potøeba ádné inverzní zobrazení. Vıstup blokové šifry se XORuje s ciphertextem a vznikne plaintext (viz obrázek \ref{OFBdecryption}). Je zøejmé, e zašifrování ani rozšifrování nelze pøi OFB paralelizovat.

Jako poslední si ukáeme mód CTR (Counter). Na vstup blokové šifry jdou data, která se pokadé o 1 zmìní. Vıstup blokové šifry (keystream) je pak XORován s plaintextem resp. ciphertextem (viz obrázky \ref{CTRencryption} a \ref{CTRdecryption}). CTR se mùe podobat ECB v tom ohledu, e lze kadı blok plaintextu je šifrován samostatnì a proto je opìt moné paralelizovat jak zašifrování, tak rozšifrování. Nicménì zde jsou jednotlivé bloky plaintextu zašifrovány jinak, i kdyby byly všechny bloky plaintextu stejné. Bezpeèností aplikace se proto CTR blíí spíše OFB. Counter posílá na vıstup keystream, kterı se skládá poustupnì z øady $f(x \oplus n), f(x \oplus (n+1)), f(x \oplus (n+2)), ...$, kde $n$ je \uv{nonce}. To je èíslo zvolené pro šifrování jedné konkrétní zprávy, které musí bıt pøiloeno k ciphertextu pro umonìní rozšifrování zprávy. Cílem je neopakovat znovu stejnı keystream pøi ponechání stejného klíèe (hraje tedy stejnou roli jako inicializaèní vektor u pøedchozích modù).

\bcmoop{CTR}{encryption}
\bcmoop{CTR}{decryption}

\section{Útoky na šifry}

Kvalita šifrování musí bıt posuzována v kontextu monıch útokù. Pokadé budeme pøedpokládat, e útoèník nezná tajnı klíè (jinak by dokázal vše), ale e dùkladnì rozumí šifrovacímu algoritmu (viz Kerckhoffùv princip).

\subsection{Rozdìlení podle povolenıch prostøedkù}

V knize \citep{Crypt} jsou útoky na šifry rozdìleny následujícím zpùsobem:

Nejslabším typem útoku je \textsl{ciphertext-only attack}. Pøi nìm má útoèník monost vidìt pouze ciphertexty. Pokud nìjakı šifrovací algoritmus snad dává monost rozluštit plaintext pouze pøi znalosti cipthertextu, je to zcela nepouitelnı algoritmus.

O mnoho silnìjší útok se nazıvá \textsl{known-plaintext attack}. Pøi nìm má útoèník k dispozici dvojice ciphertext-plaintext. Na základì nasbíranıch informací se snaí rozluštit jinı ciphertext, kterı byl zašifrovanı stejnım klíèem, jakım byly zašifrovány známé dvojice dvojice ciphertext-plaintext. Musíme poèítat, e dvojici ciphertext-plaintext mùe v praxi útoèník pomìrnì snadno získat. Napøíklad mùe útoèník uhodnout, jaká zpráva je odesílána, protoe je to zjevné z délky zprávy a širšího kontextu. Nebo mùe odesílatel zbyteènì pouít šifrovací mechanismus i v pøípadì pøenosu zprávy, která ve skuteènosti není tajná. Útoèník v danou chvíli mùe tøeba vidìt odesílateli danou zprávu pøes rameno a hned získá dvojici ciphertext-plaintext. A nakonec obèas i znalosti èásti plaintextu mùou bıt prostøedkem k útoku. Známou èástí plaintextu mùe bıt napøíklad hlavièka nìjakého standardního souboru, padding, nebo automaticky vygenerovanı podpis na konci emailu.

Ještì silnìjším útokem je \textsl{chosen-plaintext attack}. Pøi nìm si mùe útoèník sám urèit, jaká zpráva má bıt zašifrována a obdret k ní odpovídající ciphertext. Jeho cílem je zase buï pøímo odvodit šifrovací klíè, nebo jinım zpùsobem získat monost rozluštit ostatní ciphertexty.

Posledním zesílením prostøedkù k útoku je \textsl{adaptively-chosen-plaintext attack}. Pøi nìm mùe útoèník nejen analyzovat dvojice plaintext-ciphertext, ale na základì jejich znalosti volit nové zprávy k zašifrování a získávat další dvojice plaintext-ciphertext, dokud nebude mít dostatek informací.

Útoky typu adaptively-chosen-plaintext attack lze chápat jako útoky s moností neomezeného pøístupu k šifrovacímu zaøízení, uvnitø kterého se nachází šifrovací klíè (ale není vidìt navenek). Podobnım zpùsobem lze teoreticky uvaovat také útoky s pøístupem k dešifrovacímu zaøízení, tedy e si útoèník mùe libovolnì volit ciphertexty a dostává k nim pøíslušející plaintexty. Kategorii takovıch útokù bychom mohli nazvat jako \textsl{adaptively-chosen-ciphertext attack}.

\subsection{Pøíklady útokù}

Ukáeme si nìkolik jednodušších pøíkladù kryptoanalytickıch útokù.

\section{Testy}

Je pøíliš obtíné ukázat o šifrovacím algoritmu, e je doopravdy kvalitní. Jako záruka kvality se proto v praxi pouívá spíše jeho zveøejnìní na nìkolik let, aby ho mìli šanci oponovat nejlepší odborníci. Pokud se ani po nìkolika letech neukáe jeho slabina, je šifrovací algoritmus povaován za dost dobrı. Naštìstí alespoò ty velmi špatné šifrovací algoritmy je moné rychle rozpoznat statistickımi testy. Na to se zamìøíme v této práci.

\subsection{Testy na úrovni jednotlivıch vıstupù}

Pro kryptografii je potøeba, aby dlouhé klíèe mìly vlastnosti pseudonáhodnıch posloupností. Pochopitelnì zde není moné dosáhnout, aby všechny dlouhé klíèe byly stejnì pravdìpodobné a dosáhli bychom tak \uv{pravé náhodnosti}, ale mùeme alespoò otestovat konkrétní vıstup, jestli se podobá náhodné posloupnosti.

Tøída Crypto.RandomnessTesting obsahuje následující metody.
\begin{itemize}
\item EntropyTest(BitArray b, byte lengthLimit) : Testuje entropii blokù o velikosti od 1 po lengthLimit. Jde o sledování frekvence jednotlivıch blokù. V náhodné posloupnosti by mìly bıt všechny bloky stejné délky pøiblinì stejnì èasté. Vzorec pro vıpoèet entropie blokù jedné konkrétní délky, kde $p_i$ oznaèuje pravdìpodobnostii (zde relativní èetnosti) vıskytu jednotlivıch blokù, zní:
$$\sum_{i=1}^{n} p_i \cdot \log_2{\frac{1}{p_i}} = -\sum_{i=1}^{n} p_i \cdot \log_2{p_i}$$
Pro krátké posloupnosti (zde pod 10 tisíc bitù) samozøejmì není moné, aby se všechny bloky (zde délky 10) vyskytly, take jsou všechny vısledky porovnány s maximálním monım vısledkem. Vıstupem je váenı prùmìr, kde mají testy entropií všech délek vısledky v rozsahu 0 a 1. Optimální hodnota je 1.
\item CompressionTest(BitArray b) : Zkusí data zkomprimovat pomocí programu gzip s optimální úrovní komprese a vrátí pomìr mezi novou a pùvodní velikostí. O posloupnostech, které lze zkomprimovat, je známo, e nejsou dokonale náhodné. Konkrétnì velikost dat po kompresi je horním odhadem na Kolmogorovskou sloitost. Optimální hodnota je 1.
\end{itemize}

\subsection{Testy na úrovni celého zobrazení}

Skuteènost, e vıstupem algoritmu je pseudonáhodná posloupnost èísel, je jistì dobrá. Ale co kdy algoritmus všem vstupùm pøiøadí stejnou pseudonáhodnou posloupnost? Nebo jeden konkrétní bit na vstupu neovlivní vısledek? Takovou nekvalitu musí objevit druhá skupina testù.

Budeme zde zkoumat vlastnosti algoritmù jako vlastnosti celého zobrazení z krátkıch klíèù do dlouhıch klíèù. Protoe si budeme èasto klást otázky typu \uv{Jak moc se liší vıstup A od vıstupu B?}, tak by bylo vhodné zavést nìjaké hodnocení, ideálnì s vlastností metriky. Porovnávat budeme vdy jen vıstupy stejné délky. Oblíbenımi metrikami pro øetìzce jsou \textsl{Hammingova vzdálenost} a \textsl{Levenshteinova vzdálenost}. Hamming mìøí poèet pozic, na kterıch se øetìzce liší. Levenshtein mìøí minimální poèet potøebnıch zmìn k tomu, abychom z jednoho øetìzce dostali ten druhı. Jako zmìnu je moné provést zámìnu znaku, smazání znaku, nebo dopsání znaku na libovolné místo.

Hammingova vzdálenost je triviálnì horním odhadem na Levenshteinovu vzdálenost. V pøípadì náhodnıch binárních øetìzcù je jejich hodnota obèas stejná, ale nìkdy mùe bıt Levenshtein vıraznì niší. Napøíklad kdy zrotujeme øetìzec o jednu pozici, tak Levenshtein dává vzdálenost 2, zatímco Hamming mùe dát hodnì vysoké èíslo (a délka øetìzce). Vıznamná pro nás bude rychlost vıpoètu. Hammingovu vzdálenost lze triviálnì urèit v lineárním èase, ale vıpoèet Levenshteinovy vzdálenosti zabere èas kvadratickı. e to rychleji nejde, se nelze divit, protoe Levenshtein vlastnì spouští prohledávání prostoru editací. Díky dynamickému programování to lze provést alespoò v tom kvadratickém èase.

Program ještì obì vzdálenosti vydìlí délkou øetìzce, aby vısledky mìly hodnotu v rozmezí 0 (shodné øetìzce) a 1 (napøíklad øetìzec samıch nul porovnán se øetìzcem samıch jednièek). Støední hodnota pro dvojici náhodnıch binárních posloupností je u Hamminga triviálnì 0,5. Nesrovnatelnì tìší je odhadnout støední hodnotu Levenshteinovy vzdálenosti. Posloupnost støedních hodnot Levenshteina se vzrùstající délkou vstupu roste jako subaditivní posloupnost \footnote{Posloupnost $x_i$ se nazıvá subaditivní, pokud $\forall n,m \in \N :x_{n+m}\leq x_n+x_m$}, protoe vdy se pøijehorším dá upravovat levá a pravá èást souboru zvláš. Relativní hodnota proto mùe pro delší vstupy pouze klesat. Limitní hodnotu se zdá bıt pøíliš tìké odhadnout, ale orientaèní experimenty i diskuze na internetu naznaèují, e mùeme poèítat s hodnotou kolem 0,29 \citep{EDist}.

Tøída Crypto.FunctionTesting obsahuje následující metody. Podle nastavení v konstruktoru mohou všechny testy pouívat buï Hammingovu, nebo Levensteinovu vzdálenost. Dále uvádìno podle Hamminga.
\begin{itemize}
\item TestAverageDistance(IKeyExtender algorithm, int ratio) : Testuje prùmìrnou vzdálenost vıstupù pøíslušející dvìma rùznım náhodnì zvolenım vstupùm. Optimální hodnota je 0,5.
\item TestBitChange(IKeyExtender algorithm, int ratio) : Testuje, jak velká èást bitù vıstupu se zmìní pøi zmìnì jednoho bitu vstupu. Metoda sampluje náhodné vstupy a pro kadı z nich zkouší zmìnit zvláš všechny bity. Optimální hodnota je 0,5.

TestBitChange je z praktického hlediska pøísnìjší ne TestAverageDistance. Pøestoe pro naše úèely lze TestAverageDistance chápat jako horní odhad vısledku TestBitChange, lze teoreticky vymyslet i zobrazení, které v TestBitChange dopadne dobøe, ale v TestAverageDistance sele. Napøíklad kdy všem vstupùm se sudou paritou pøiøadíme vısledek ze samıch nul (000...0) a všechny vstupy s lichou paritou zobrazíme na pravidelné støídání hodnot nula a jedna (010101...01), tak TestBitChange dosáhne optimálního vısledku 0,5, zatímco TestAverageDistance vykáe velmi podezøelou hodnotu 0,25.
\item TestLargestBallExactly(IKeyExtender algorithm) : Testuje, jaká nejvìtší koule se dá vmìstnat do prostoru vıstupù tak, aby neobsahovala ádnı vygenerovatelnı dlouhı klíè. Zkouší úplnì všechny vstupy na malém prostoru a ty natahuje na dvojnásobek. Motivací je, e pokud zobrazení nazaplòuje prostor dostateènì rovnomìrnì, pak to rozpoznáme tak, e se do prostoru vejde velká koule.
\item TestLargestBallApprox(IKeyExtender algorithm) : Testuje to samé, ale pouívá delší vstupy, které u nezvládá vyzkoušet všechny, take je sampluje náhodnì.
\end{itemize}

\subsection{Pouití testù}

Všechny doposud zmínìné testy jsou obaleny ve tøídì Crypto.FunctionTestsForThesis, kde jsou vısledky tìchto testù transformovány zpùsobem, kterı zaruèí, e vyšší vısledek je lepší. S vıjimkou testù maximálních koulí, které jsou realizovány v této tøídì trochu jinak, platí, e nejhorší hodnota je 0 a nejlepší hodnota je 1.

\subsection{Grafické znázornìní}

Vısledky jednotlivıch algoritmù ve vıše uvedenıch testech budeme znázoròovat na diagramech jako je ten na obrázku \ref{ukazka}.
 
\newcommand{\radar}[7]{\begin{figure}[h]
\begin{tikzpicture}[label distance=.15cm]
 \tkzKiviatDiagram[radial=5, lattice=3, gap=1, step=3]{Entropy, Compress, AveDistan, BitChange, LargeBall}
  \tkzKiviatLine[thick, color=blue, mark=ball, ball color=red, mark size=4pt, opacity=0.2, fill=blue!20]({#1}, {#2}, {#3}, {#4}, {#5})
\end{tikzpicture}
\caption{#6}
\label{#7}
\end{figure}}
 
\radar{0.9}{0.55}{0.95}{0.7}{0.52}{Ukázkovı radar chart}{ukazka}

Pro diagramy jsou hodnoty pøeškálovány. S vıjimkou testù nejvìtších koulí, kde neznáme optimální hodnotu, je škálování takové, aby optimální hodnota byla 1. Tedy napøíklad kdy TestBitChange vrátí hodnotu $x$, pak je do diagramu zobrazeno 
$$\min\{2x, 2(1-x)\}$$, aby optimum (zanesené jako hodnota 1) byl vısledek 0,5 a odchylky na obì strany \uv{stejnì váné}.