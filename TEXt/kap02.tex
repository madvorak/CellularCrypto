%%% Kapitola o šifrování

\chapter{Šifrování}

Vìda zabıvající se šifrováním se nazıvá \textsl{kryptografie}. Lámáním šifer se zase zabıvá  \textsl{kryptoanalıza}. Úkolem šifrování je uchovat a pøedat tajnou zprávu tak, aby ji mohl pøeèíst ten, pro koho je urèena, ale u nikdo jinı. Dále se nìkdy za cíl dává ovìøitelnost autora zprávy.

Pùvodní èitelná zpráva se nazıvá \textsl{plaintext}. Data po zašifrování se nazıvají \textsl{ciphertext}. Pro pøevod plaintextu na ciphertext je potøeba pouít šifrovací algoritmus. Ten by mìl zároveò bıt schopen pøevézt ciphertext zpìt na plaintext (tzv. dešifrování). Protoe fungování šifrovacího algoritmu se velmi snadno vyzradí, zásadní roli hraje \textsl{šifrovací klíè}. Pokud se jedná o \textsl{symetrickou kryptografii}, tak stejnı klíè slouí i k dešifrování. V pøípadì \textsl{asymetrické kryptografie} se pouívají dva rùzné klíèe. Šifrovací resp. dešifrovací klíèe v asymetrické kryptografii se s ohledem na jejich pouití nazıvají jako \textsl{veøejnı} resp. \textsl{tajnı} klíè.

Pøed zašifrováním zprávy se èasto provádí její \textsl{komprese}. To má za následek nejen úsporu pøenosového pásma a mnoství práce (èasu) šifrovacího algoritmu, ale velkou vıhodou je dosaení vıraznì rovnomìrnìjšího pravdìpodobnostního rozdìlení na prostoru plaintextù, co vıraznì komplikuje kryptoanalızu.

\section{Nìkolik ukázek}

Jedinou zcela nerozluštitelnou šifrovací metodou je Vernamova šifra. V binární podobì tato šifra vypadá tak, e se pouije one-time pad, co je sekvence náhodnıch bitù, kterou vlastní obì strany. Odesílatel provede operaci plaintext XOR one-time pad a pøíjemce provede operaci ciphertext XOR one-time pad, cím dostane zpìt plaintext. Problém je, e one-time pad musí bıt stejnì dlouhı jako plaintext a nelze ho pouít opakovanì. Kvùli tomu se Vernamova šifra pouívá jen pro kritické aplikace, pøed kterımi se mohou komunikující strany fyzicky setkat a pøedat si one-time pad.

V této práci se budeme vìnovat vytvoøení algoritmu na protahování klíèù (anglicky key stretching). Cílem je z krátkého klíèe (kterı lze napøíklad v krátkém èase pøenést pomocí RSA) vygenerovat dlouhı klíè (onen one-time pad, kterım lze pøeXORovat celı soubor). Je to tedy podobnı úkol jako naprogramovat \textsl{Key Stream Generator}, akorát my budeme dopøedu vìdìt cílenou délku vısledného klíèe.

Jako Key Stream Generator se dá pouít napøíklad mnoho blokovıch šifer. U blokovıch šifer záleí na módu operace. Pøi \textsl{Cipher Block Chaining} (CBC, PCBC) èi \textsl{Cipher Feedback} (CFB) módu zašifrování druhé èásti plaintextu záleí na vısledku zašifrování první èásti, tudí to není Key Stream Generator. Ale pøi zapojení jako tøeba \textsl{Counter} (CTR) vzniká proud bitù bez znalosti plaintextu, take získáme Key Stream Generator. Dobrım pøíklalem je tøeba AES-CTR.

\section{Pseudonáhodné generátory}

Jako velmi jednoduchı Key Stream Generator by se dal pouít nìjakı z generátorù pseudonáhodnıch èísel. Narozdíl od \uv{opravdovıch} generátorù náhodnıch èísel, které pouívají nìjakı fyzikální zdroj náhody (tøeba radioaktivní rozpad), jsou hodnoty vytváøené generátorem pseudonáhodnıch èísel deterministicky urèeny poèáteèní hodnotou (tzv. seed), která mùe bıt zvolena na základì krátkého klíèe.

Typickım pøíkladem mùe bıt lineární kongruenèní generátor pseudonáhodnıch èísel (LCG). Ten je charakterizován rozsahem hodnot $m$, koeficientem $a$, inkrementem $c$ a poèáteèní hodnotou $X_0$. LCG provádí krok podle vzorce:
$$X_{n+1} = (aX_n + c) \mod m$$
a mají dlouhou periodu. Podmínky pro to, aby LCG mìl periodu délky $m$ (tj. vystøídal všechny moné hodnoty), jsou následující (viz Knuth):
\begin{itemize}
\item $c$ a $m$ jsou nesoudìlná èísla
\item $a-1$ je dìlitelné všemi prvoèiniteli $m$
\item pokud je $m$ dìlitelné 4, je i $a-1$ dìlitelné 4
\end{itemize}
Tøetí pravidlo je velice dùleité, protoe s ohledem na vıkon programu na reálnıch procesorech se obvykle volí m v hodnotì mocniny dvou\footnote{Bìnì se pouívá nastavení, kde rozsah je mocnina dvou ($m = 2^n$, kde n je èíslo od 24 do 64), $c=1$, $a$ libovolné takové, e $1 \equiv a \mod 4$}.

Jako pseudonáhodnou posloupnost není dobré pouít pøímo hodnoty $X_i$. Problém je zejména vidìt tehdy, kdy $m = 2^n$. Pak se lze podívat na posledních $d$ bitù èísel $X_i$, oznaème je $Y_i = X_i \mod 2^d$. Ty tvoøí posloupnost s kratší periodou. Její pøedpis lze napsat stejnım zpùsobem, jako pøedpis pro LCG:
$$Y_{n+1} = (qY_n+r) \mod 2^d$$, kde $q = a \mod 2^d$, $r = c \mod 2^d$.

Øešením je pouití jen nìkolika poèáteèních bitù z kadého $X_i$. Pokud by se na vıstup posílala celá hodnota $X_i$, byla by èást bitù snadno pøedvídatelná. Napøíklad kadı $m$-tı bit vıstupu by pravidelnì støídal 0 a 1.

Existují i jiné generátory pseudonáhodnıch èísel, které jsou vhodnìjší pro kryptografické úèely. Ve skuteènosti není skoro ádnı rozdíl mezi Key Stream Generator a genetárorem pseudonáhodnıch èísel. Odlišuje je jen to, e generátory pseudonáhodnıch èísel pouívají seed menší velikosti, kdeto Key Stream Generator lze inicializovat klíèem vìtší velikosti.

\section{Testy}

Je pøíliš obtíné ukázat o šifrovacím algoritmu, e je doopravdy kvalitní. Jako záruka kvality se proto v praxi pouívá spíše jeho zveøejnìní na nìkolik let, aby ho mìli šanci oponovat nejlepší odborníci. Pokud se ani po nìkolika letech neukáe jeho slabina, je šifrovací algoritmus povaován za dost dobrı. Naštìstí alespoò ty velmi špatné šifrovací algoritmy je moné rychle rozpoznat statistickımi testy. Na to se zamìøíme v této práci.

\subsection{Testy na úrovni jednotlivıch vıstupù}

Pro kryptografii je potøeba, aby dlouhé klíèe mìly vlastnosti pseudonáhodnıch posloupností. Pochopitelnì zde není moné dosáhnout, aby všechny dlouhé klíèe byly stejnì pravdìpodobné a dosáhli bychom tak \uv{pravé náhodnosti}, ale mùeme alespoò otestovat konkrétní vıstup, jestli se podobá náhodné posloupnosti.

Tøída Crypto.RandomnessTesting obsahuje následující metody.
\begin{itemize}
\item EntropyTest(BitArray b, byte lengthLimit) : Testuje entropii blokù o velikosti od 1 po lengthLimit. Jde o sledování frekvence jednotlivıch blokù. V náhodné posloupnosti by mìly bıt všechny bloky stejné délky pøiblinì stejnì èasté. Pro krátké posloupnosti (zde pod 10 tisíc bitù) samozøejmì není moné, aby se všechny bloky (zde délky 10) vyskytly, take jsou všechny vısledky porovnány s maximálním monım vısledkem. Vıstupem je váenı prùmìr, kde mají testy entropií všech délek vısledky v rozsahu 0 a 1. Optimální hodnota je 1.
\item CompressionTest(BitArray b) : Zkusí data zkomprimovat pomocí programu gzip s optimální úrovní komprese a vrátí pomìr mezi novou a pùvodní velikostí. O posloupnostech, které lze zkomprimovat, je známo, e nejsou dokonale náhodné. Konkrétnì velikost dat po kompresi je horním odhadem na Kolmogorovskou sloitost. Optimální hodnota je 1.
\end{itemize}

\subsection{Testy na úrovni celého zobrazení}

Skuteènost, e vıstupem algoritmu je pseudonáhodná posloupnost èísel, je jistì dobrá. Ale co kdy algoritmus všem vstupùm pøiøadí stejnou pseudonáhodnou posloupnost? Nebo jeden konkrétní bit na vstupu neovlivní vısledek? Takovou nekvalitu musí objevit druhá skupina testù.

Budeme zde zkoumat vlastnosti algoritmù jako vlastnosti celého zobrazení z krátkıch klíèù do dlouhıch klíèù. Protoe si budeme èasto klást otázky typu \uv{Jak moc se liší vıstup A od vıstupu B?}, tak by bylo vhodné zavést nìjaké hodnocení, ideálnì s vlastností metriky. Porovnávat budeme vdy jen vıstupy stejné délky. Oblíbenımi metrikami pro øetìzce jsou \textsl{Hammingova vzdálenost} a \textsl{Levenshteinova vzdálenost}. Hamming mìøí poèet pozic, na kterıch se øetìzce liší. Levenshtein mìøí minimální poèet potøebnıch zmìn k tomu, abychom z jednoho øetìzce dostali ten druhı. Jako zmìnu je moné provést zámìnu znaku, smazání znaku, nebo dopsání znaku na libovolné místo.

Hammingova vzdálenost je triviálnì horním odhadem na Levenshteinovu vzdálenost. V pøípadì náhodnıch binárních øetìzcù je jejich hodnota obèas stejná, ale nìkdy mùe bıt Levenshtein vıraznì niší. Napøíklad kdy zrotujeme øetìzec o jednu pozici, tak Levenshtein dává vzdálenost 2, zatímco Hamming mùe dát hodnì vysoké èíslo (a délka øetìzce). Vıznamná pro nás bude rychlost vıpoètu. Hammingovu vzdálenost lze triviálnì urèit v lineárním èase, ale vıpoèet Levenshteinovy vzdálenosti zabere èas kvadratickı. e to rychleji nejde, se nelze divit, protoe Levenshtein vlastnì spouští prohledávání prostoru editací. Díky dynamickému programování to lze provést alespoò v tom kvadratickém èase.

Program ještì obì vzdálenosti vydìlí délkou øetìzce, aby vısledky mìly hodnotu v rozmezí 0 (shodné øetìzce) a 1 (napøíklad øetìzec samıch nul porovnán se øetìzcem samıch jednièek). Støední hodnota pro dvojici náhodnıch binárních posloupností je u Hamminga triviálnì 0,5. Nesrovnatelnì tìší je odhadnout støední hodnotu Levenshteinovy vzdálenosti. Posloupnost støedních hodnot Levenshteina se vzrùstající délkou vstupu roste jako subaditivní posloupnost. Relativní hodnota proto mùe pro delší vstupy pouze klesat. Limitní hodnotu se zdá bıt pøíliš tìké odhadnout, ale orientaèní experimenty i diskuze na internetu naznaèují, e mùeme poèítat s hodnotou kolem 0,29.

Tøída Crypto.FunctionTesting obsahuje následující metody. Podle nastavení v konstruktoru mohou všechny testy pouívat buï Hammingovu, nebo Levensteinovu vzdálenost. Dále uvádìno podle Hamminga.
\begin{itemize}
\item TestBitChange(IKeyExtender algorithm, int ratio) : Testuje, jak velká èást bitù vıstupu se zmìní pøi zmìnì jednoho bitu vstupu. Metoda sampluje náhodné vstupy a pro kadı z nich zkouší zmìnit zvláš všechny bity. Optimální hodnota je 0,5.
\item TestAverageDistance(IKeyExtender algorithm, int ratio) : Testuje prùmìrnou vzdálenost vıstupù pøíslušející dvìma rùznım náhodnì zvolenım vstupùm. Optimální hodnota je 0,5.
\item TestLargestBallExactly(IKeyExtender algorithm) : Testuje, jaká nejvìtší koule se dá vmìstnat do prostoru vıstupù tak, aby neobsahovala ádnı vygenerovatelnı dlouhı klíè. Zkouší úplnì všechny vstupy na malém prostoru a ty natahuje na dvojnásobek. Motivací je, e pokud zobrazení nazaplòuje prostor dostateènì rovnomìrnì, pak to rozpoznáme tak, e se do prostoru vejde velká koule.
\item TestLargestBallApprox(IKeyExtender algorithm) : Testuje to samé, ale pouívá delší vstupy, které u nezvládá vyzkoušet všechny, take je sampluje náhodnì.
\end{itemize}

\subsection{Pouití testù}

Všechny doposud zmínìné testy jsou obaleny ve tøídì Crypto.FunctionTestsForThesis, kde jsou vısledky tìchto testù transformovány zpùsobem, kterı zaruèí, e vyšší vısledek je lepší. S vıjimkou testù maximálních koulí, které jsou realizovány v této tøídì trochu jinak, platí, e nejhorší hodnota je 0 a nejlepší hodnota je 1.

\subsection{Grafické znázornìní}

Vısledky jednotlivıch algoritmù ve vıše uvedenıch testech budeme znázoròovat na diagramech jako je tento:
 
\newcommand{\radar}[7]{\begin{figure}
\begin{tikzpicture}[label distance=.15cm]
 \tkzKiviatDiagram[radial=5, lattice=3, gap=1, step=3]{Entropy, Compression, AveDistance, BitChange, LargestBall}
  \tkzKiviatLine[thick, color=blue, mark=ball, ball color=red, mark size=4pt, opacity=0.2, fill=blue!20]({#1}, {#2}, {#3}, {#4}, {#5})
\end{tikzpicture}
\caption{#6}
\label{#7}
\end{figure}}
 
\radar{0.9}{0.55}{0.95}{0.7}{0.52}{Ukázkovı radar chart}{label}

Pro diagramy jsou hodnoty pøeškálovány. S vıjimkou testù nejvìtších koulí, kde neznáme optimální hodnotu, je škálování takové, aby optimální hodnota byla 1. Tedy napøíklad kdy TestBitChange vrátí hodnotu $x$, pak je do diagramu zobrazeno 
$$\min\{2x, 2(1-x)\}$$, aby optimum (zanesené jako hodnota 1) byl vısledek 0,5 a odchylky na obì strany \uv{stejnì váné}.