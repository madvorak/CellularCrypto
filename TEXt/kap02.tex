%%% Kapitola o šifrování

\chapter{Šifrování}

Vìda zabıvající se šifrováním se nazıvá \textsl{kryptografie}. Lámáním šifer se zase zabıvá  \textsl{kryptoanalıza}. Úkolem šifrování je uchovat a pøedat tajnou zprávu tak, aby ji mohl pøeèíst ten, pro koho je urèena, ale u nikdo jinı. Dále se nìkdy za cíl dává ovìøitelnost autora zprávy.

Pùvodní èitelná zpráva se nazıvá \textsl{plaintext}. Data po zašifrování se nazıvají \textsl{ciphertext}. Pro pøevod plaintextu na ciphertext je potøeba pouít šifrovací algoritmus. Ten by mìl zároveò bıt schopen pøevézt ciphertext zpìt na plaintext (tzv. dešifrování). Protoe fungování šifrovacího algoritmu se velmi snadno vyzradí, zásadní roli hraje \textsl{šifrovací klíè}. Pokud se jedná o \textsl{symetrickou kryptografii}, tak stejnı klíè slouí i k dešifrování. V pøípadì \textsl{asymetrické kryptografie} se pouívají dva rùzné klíèe. Šifrovací resp. dešifrovací klíèe v asymetrické kryptografii se s ohledem na jejich pouití nazıvají jako \textsl{veøejnı} resp. \textsl{tajnı} klíè.

Pøed zašifrováním zprávy se èasto provádí její \textsl{komprese}. To má za následek nejen úsporu pøenosového pásma a mnoství práce (èasu) šifrovacího algoritmu, ale velkou vıhodou je dosaení vıraznì rovnomìrnìjšího pravdìpodobnostního rozdìlení na prostoru plaintextù, co vıraznì komplikuje kryptoanalızu.

\section{Nìkolik ukázek}

bla bla bla

V této práci se budeme vìnovat vytvoøení algoritmu na protahování klíèù (anglicky key stretching). Cílem je z krátkého klíèe (kterı lze napøíklad v krátkém èase pøenést pomocí RSA) vygenerovat dlouhı klíè (kterım lze pøeXORovat celı soubor). Je to tedy podobnı úkol jako naprogramovat \textsl{Key Stream Generator}, akorát my budeme dopøedu vìdìt cílenou délku vısledného klíèe. 

Jako Key Stream Generator se dá pouít napøíklad mnoho blokovıch šifer. U blokovıch šifer záleí na módu operace. Pøi \textsl{Cipher Block Chaining} (CBC, PCBC) èi \textsl{Cipher Feedback} (CFB) módu zašifrování druhé èásti plaintextu záleí na vısledku zašifrování první èásti, tudí to není Key Stream Generator. Ale pøi zapojení jako tøeba \textsl{Counter} (CTR) vzniká proud bitù bez znalosti plaintextu, take získáme Key Stream Generator. Dobrım pøíklalem je tøeba AES-CTR.

\section{Testy}

Je pøíliš obtíné ukázat o šifrovacím algoritmu, e je doopravdy kvalitní. Jako záruka kvality se proto v praxi pouívá spíše jeho zveøejnìní na nìkolik let, aby ho mìli šanci oponovat nejlepší odborníci. Pokud se ani po nìkolika letech neukáe jeho slabina, je šifrovací algoritmus povaován za dost dobrı. Naštìstí alespoò ty velmi špatnì šifrovací algoritmy je moné rychle rozpoznat statistickımi testy. Na to se zamìøíme v této práci.

\subsection{Testy na úrovni jednotlivıch vıstupù}

Pro kryptografii je potøeba, aby dlouhé klíèe mìly vlastnosti pseudonáhodnıch posloupností. Pochopitelnì zde není moné dosáhnout, aby všechny dlouhé klíèe byly stejnì pravdìpodobné a dosáhli bychom tak \uv{pravé náhodnosti}, ale mùeme alespoò otestovat konkrétní vıstup, jestli se podobá náhodné posloupnosti.

Tøída Crypto.RandomnessTesting obsahuje následující metody.
\begin{itemize}
\item EntropyTest(BitArray b, byte lengthLimit) : Testuje entropii blokù o velikosti od 1 po lengthLimit (pouívána hodnota 10). Jde o sledování frekvence jednotlivıch blokù. V náhodné posloupnosti by mìly bıt všechny bloky stejné délky pøiblinì stejnì èasté. Pro krátké posloupnosti (zde pod 10 tisíc bitù) samozøejmì není moné, aby se všechny bloky (zde délky 10) vyskytly, take jsou všechny vısledky porovnány s maximálním monım vısledkem. Vıstupem je váenı prùmìr, kde mají testy entropií všech délek vısledky v rozsahu 0 a 1. Optimální hodnota je 1.
\item CompressionTest(BitArray b) : Zkusí data zkomprimovat pomocí programu gzip s optimální úrovní komprese a vrátí pomìr mezi novou a pùvodní velikostí. O posloupnostech, které lze zkomprimovat, je známo, e nejsou dokonale náhodné. Konkrétnì velikost dat po kompresi je horním odhadem na Kolmogorovskou sloitost. Optimální hodnota je 1.
\end{itemize}

\subsection{Testy na úrovni celého zobrazení}

Skuteènost, e vıstupem algoritmu je pseudonáhodná posloupnost èísel, je jistì dobrá. Ale co kdy algoritmus všem vstupùm pøiøadí stejnou pseudonáhodnou posloupnost? Nebo jeden konkrétní bit na vstupu neovlivní vısledek? Takovou nekvalitu musí objevit druhá skupina testù.

Budeme zde zkoumat vlastnosti algoritmù jako vlastnosti celého zobrazení z krátkıch klíèù do dlouhıch klíèù. Protoe si budeme èasto klást otázky typu \uv{Jak moc se liší vıstup A od vıstupu B?}, tak by bylo vhodné zavést nìjaké hodnocení, ideálnì s vlastností metriky. Porovnávat budeme vdy jen vıstupy stejné délky. Oblíbenımi metrikami pro øetìzce jsou \textsl{Hammingova vzdálenost} a \textsl{Levenshteinova vzdálenost}. Hamming mìøí poèet pozic, na kterıch se øetìzce liší. Levenshtein mìøí minimální poèet potøebnıch zmìn k tomu, abychom z jednoho øetìzce dostali ten druhı. Jako zmìnu je moné provést zámìnu znaku, smazání znaku, nebo dopsání znaku na libovolné místo.

Hammingova vzdálenost je triviálnì horním odhadem na Levenshteinovu vzdálenost. V pøípadì náhodnıch binárních øetìzcù je jejich hodnota èasto stejná, ale nìkdy mùu bıt Levenshtein vıraznì niší. Napøíklad kdy zrotujeme øetìzec o jednu pozici, tak Levenshtein dává vzdálenost 2, zatímco Hamming mùe dát hodnì vysoké èíslo. Vıznamná pro nás bude rychlost vıpoètu. Hammingovu vzdálenost lze triviálnì urèit v lineárním èase, ale vıpoèet Levenshteinovy vzdálenost zabere èas kvadratickı. e to rychleji nejde, se nelze divit, protoe Levenshtein vlastnì spouští prohledávání prostoru editací. Díky dynamickému programování to lze provést alespoò v tom kvadratickém èase.

Program ještì obì vzdálenosti pøeškáluje, aby vısledky mìly hodnotu v rozmezí 0 (shodné øetìzce) a 1 (øetìzec samıch nul porovnán se øetìzcem samıch jednièek). Støední hodnota pro dvojici náhodnıch binárních posloupností je u Hamminga triviálnì 0,5. Nesrovnatelnì tìší je odhadnout støední hodnotu Levenshteinovy vzdálenosti. Posloupnost støedních hodnot Levenshteina se vzrùstající délkou vstupu roste jako subaditivní posloupnost. Pøeškálovaná hodnota proto mùe pro delší vstupy pouze klesat. Limitní hodnotu se zdá bıt pøíliš tìké odhadnout, ale orientaèní experimenty i diskuze na internetu naznaèují, e mùeme poèítat s hodnotou  kolem 0,29.

Tøída Crypto.FunctionTesting obsahuje následující metody. Podle nastavení v konstruktoru mohou všechny testy pouívat buï Hammingovu, nebo Levensteinovu vzdálenost. Dále uvádìno podle Hamminga.
\begin{itemize}
\item TestBitChange(IKeyExtender algorithm, int ratio) : Testuje, jak velká èást bitù vıstupu se zmìní pøi zmìnì jednoho bitù vstupu. Metoda sampluje náhodné vstupy a pro kadı z nich zkouší zmìnit zvláš všechny bity. Optimální hodnota je 0,5.
\item TestAverageDistance(IKeyExtender algorithm, int ratio) : Testuje prùmìrnou vzdálenost vıstupù pøíslušející dvìma rùznım náhodnì zvolenım vstupùm. Optimální hodnota je 0,5.
\item TestLargestBallExactly(IKeyExtender algorithm) : Testuje, jaká nejvìtší koule se dá vmìstnat do prostoru vıstupù tak, aby neobsahovala ádnı vygenerovatelnı dlouhı klíè. Zkouší úplnì všechny vstupy na malém prostoru a ty natahuje na dvojnásobek. Motivací je, e pokud zobrazení nazaplòuje prostor dostateènì rovnomìrnì, pak to rozpoznáme tak, e se do prostoru vejde velká koule.
\item TestLargestBallApprox(IKeyExtender algorithm) : Testuje to samé, ale pouívá delší vstupy, které u nezvládá vyzkoušet všechny, take je sampluje náhodnì.
\end{itemize}

\section{asdf}

bla bla