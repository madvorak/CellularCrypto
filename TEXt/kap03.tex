
%%% Zpùsoby protahování klíèù

\chapter{Protahování klíèù pomocí celulárních automatù}

V rámci práce na roèníkovém projektu byla vytvoøena øada rùzných celulárních automatù (potomci abstraktní tøídy CellularAutomaton), viz tøetí kapitola. Vìtšina z nich je binárních (tj. každá buòka mùže nabývat jen dvou rùzných stavù) a ty zároveò implementují rozhraní IBinaryCA, které vynucuje vìtšinu pro nás užiteèných metod.

V rámci bakaláøské práce byly vytvoøeny algoritmy na protahování klíèù, které binární celulární automaty využívají. Všechny tyto algoritmy implementují rozhraní IKeyExtender. Toto rozhraní obsahuje metodu DoubleKey pro vytvoøení klíèe s pøesnì dvojnásobnou délkou a metodu ExtendKey pro natažení klíèe na libovolnou zadanou délku. Vstupy i výstupy musí být typu BitArray, což je pole logických hodnot, které však v 1 bytu ukládá 8 hodnot (na rozdíl od bool[~]).

\begin{figure}[!h]
\centering
\includegraphics[width=107mm, height=39mm]{diagramKEAN.png}
\caption{KeyExtenderAbstractN}
\label{kean}
\end{figure}

Pøi vytváøení instancí tøíd implementujících IKeyExtender se skrze konstruktor vkládá dovnitø libovolná implementace IBinaryCA. To umožòuje zvolit si zvláš druh automatu, který urèuje fungování pøechodové funkce, a zvláš protahovací algoritmus, který urèuje zpùsob ètení hodnot z automatu a jejich využití. Jedná se tedy o techniku \uv{Inversion of control}. To se hodí, abychom mohli snadno zkoušet všechny možné zpùsoby protahování klíèù. Pokud je dovnitø algoritmu vložen 2D automat, pak se stejnì indexuje jednorozmìrnì (pøi ètení hodnot ze stavu je opravdu jedno, jak funguje automat).

\begin{figure}[!h]
\centering
\includegraphics[width=144mm, height=39mm]{diagramKEAD.png}
\caption{KeyExtenderAbstractD}
\label{kead}
\end{figure}

Nìkteré z algoritmù pøímo generují dlouhý klíè zadané délky -- ty dìdí od abstraktní tøídy KeyExtenderAbstractN (viz \ref{kean}). Tato tøída pøekládá volání DoubleKey na volání ExtendKey a potomci této tøídy implementují pouze ExtendKey. Jiné algoritmy vždy prodlouží klíè na dvojnásobek a obecné natažení realizují iterací tohoto postupu -- ty jsou odvozené od abstraktní tøídy KeyExtenderAbstractD (viz \ref{kead}). Ta realizuje metodu ExtendKey pomocí logaritmického poètu volání DoubleKey a oøezává výsledek na správnou velikost. Potomci této tøídy implementují již pouze DoubleKey.

\radar{0.659}{0.022}{0.997}{0.020}{0.125}{KeyExtenderCopy}{copy}

\radar{0.984}{0.993}{1.000}{1.000}{0.775}{KeyExtenderCheating}{cheat}

Kromì opravdových algoritmù byly vytvoøeny ještì dva falešné algoritmy pro úèely demonstrace, nakolik jsou kritické naše testovací metody. KeyExtenderCopy jen kopíruje kratší klíè dokola. Jeho výsledek znázoròuje obrázek \ref{copy}. KeyExtenderCheating vylosuje pseudonáhodnou posloupnost bez ohledu na vstup. Jak hezky vypadá výsledek podvodného generátoru, si mùžeme prohlédnout na obrázku \ref{cheat}.

\section{KeyExtenderQuadratic}

\radar{0.000}{0.000}{0.653}{0.020}{0.000}{KeyExtenderSimpleQuadratic na automat 220}{Q220}

\radar{0.043}{0.005}{0.972}{0.046}{0.350}{KeyExtenderSimpleQuadratic na automat 94}{Q94}

\radar{0.683}{0.277}{0.512}{0.249}{0.000}{KeyExtenderSimpleQuadratic na automat 90}{Q90}

\radar{0.983}{0.993}{1.000}{0.856}{0.631}{KeyExtenderSimpleQuadratic na automat 30}{Q30}

\radar{0.634}{0.096}{0.988}{0.835}{0.450}{KeyExtenderSimpleQuadratic na automat 110}{Q110}

Stephen Wolfram popisuje (viz \citep{W02}, strana 30), že když se použije elementární automat èíslo 30 na pole obsahující jednu 1 uprostøed (jinak samé 0) a sleduje se, jak se mìní prostøední buòka v èase (podobnì jako na obrázku \ref{ca30}), tak její vývoj je perfektní pseudonáhodnou posloupností (splòující všechny testy pseudonáhodnosti, které vyzkoušel). To nás vede k otázce, jestli by z jiných poèáteèních stavù vznikly jiné kvalitní pseudonáhodné posloupnosti. Wolfram dále ukazuje (viz \citep{W02}, strana 251), že když na pseudonáhodném vstupu (poèáteèním stavu) automatu 30 zmìní jediný bit, tak se zmìna propaguje dolù a doprava, ale doleva se témìø nepropaguje. To zøejmì nebude platit zcela obecnì, protože tøeba pro zmìnu samých 0 na jednu 1 dojde ke zmìnì, která se šíøí do všech stran maximální rychlostí. Jeví se proto jako pravdìpodobné, že vývoj prostøední buòky automatu 30 je ovlivnìn postupnì všemi buòkami nalevo a minimálnì nìkterými buòkami napravo.

A teï už k vlastnímu algoritmu:  Nejprve je vytvoøen celulární automat, který je dva a pùl krát širší než délka krátkého klíèe. Ten krátký klíè uloží do jeho prostøedních bunìk. Tedy klíè délky $n$ se uloží do stavu automatu s $2,5n$ buòkami a to od $0,75n$ po $1,75n$. Pak automat udìlá $2n$ krokù. Výstup se ète z prostøední buòky (1 bit po každém kroku automatu). Pùvodní návrh používal nekoneènou plochu, ale protože nám staèí natažení na $2n$, tak plocha o šíøce $2,5n$ funguje stejnì, jako kdyby se automat mohl rozpínat do nekoneèna (efekt okraje se už nestaèí promítnout do stavu prostøední buòky).

\radar{0.789}{0.684}{0.799}{0.797}{0.400}{KeyExtenderSimpleQuadratic na omezený automat s dosahem dvou polí}{Qwide}

\radar{0.787}{0.678}{0.808}{0.802}{0.375}{KeyExtenderSimpleQuadratic na cyklický automat s dosahem dvou polí}{Qcycl}

Je jisté, že výsledky testù budou silnì záviset na použitém celulárním automatu. Napøíklad pokud podkladový automat vykazuje vìtší èetnost 1 než 0 (èi naopak), tak tím pravdìpodobnì budou negativnì ovlivnìny výsledky všech testù a o vìtšinì z testù (Entropy, Compress, AveDistan, BitChange) se také dá snadno ukázat, že se ani optimální hodnotì pøi nevyrovnaných èetnostech 0 a 1 nemohou blížit.

Vidíme, že použití automatù s monotónním chováním vede k pøíšernì špatným výsledkùm (napøíklad viz \ref{Q220}). Automaty s fraktálním chováním na tom také nejsou dobøe (tøeba viz \ref{Q90}), ale automat èíslo 30, který vykazuje pseudonáhodné chování, dává opravdu vynikající výsledek (viz \ref{Q30}). Použití náhodného (i když jinak kvalitnì zvoleného) automatu s dosahem dvou polí vede jen k prùmìrnému výsledku (jako tøeba na obrázku \ref{Qwide}). Celkovì mùžeme dospìt k závìru, že chování algoritmu pro správnì zvolené automaty (napøíklad ten 30) je velmi uspokojivé, ale jeho kvadratická èasová složitost ho èiní nepoužitelným pro šifrování delších souborù (aby vznikl dostateèný one-time pad pro zašifrování 1MB velkého souboru, tak bychom museli provést 8 milionù krokù automatu, což pøedstavuje $1,6 \cdot 10^{14}$ vyvolání pøechodové funkce, což by na dnešních procesorech trvalo øádovì jeden den).

\section{KeyExtenderSimpleLinear}

Nejjednodušší zpùsob, jak natáhnout klíè na dvojnásobek. Tento algoritmus použije vstup jako poèáteèní konfiguraci celulárního automatu. Pak udìlá krok a uloží jeho stav do první poloviny dlouhého klíèe (postupnì ze všech bunìk). Pak udìlá druhý krok a naète druhou polovinu dlouhého klíèe.  Pøi použití elementárního automatu èíslo 204 jeho chování degeneruje na kopírování hodnot (stejný výstup jako KeyExtenderCopy), ale tím se zabývat nebudeme. Pøi použití automatu èíslo 51 je druhá polovina výstupu pøesnou negací první poloviny výstupu, což je stejnì tak nezajímavé.

\radar{0.548}{0.024}{0.771}{0.022}{0.075}{KeyExtenderSimpleLinear na automat 220}{L220}

\radar{0.608}{0.079}{0.978}{0.062}{0.450}{KeyExtenderSimpleLinear na automat 94}{L94}

\radar{0.904}{0.183}{0.999}{0.062}{0.788}{KeyExtenderSimpleLinear na automat 90}{L90}

\radar{0.894}{0.172}{0.997}{0.084}{0.463}{KeyExtenderSimpleLinear na automat 30}{L30}

\radar{0.857}{0.174}{0.995}{0.076}{0.438}{KeyExtenderSimpleLinear na automat 110}{L110}

Od tohoto algoritmu nemùžeme èekat moc krásné chování. Napøíklad pøi jeho aplikaci s elementárním automatem za úèelem natažením klíèe na dvojnásobek dochází k tomu, že když zmìníme 1 bit na vstupu, nemùže se zmìnit více než 8 bitù na výstupu (a konkrétní podoba této zmìny je urèena jen 9 sousedními buòkami v pùvodním stavu). Pro 2D automaty nebo automaty využívající v pøechodové funkci vìtší okolí budou sice tato èísla vyšší, ale stále to budou nìjaké konstanty, které nezávisí na velikosti klíèe.

%00010010111111001100100010011110
\radar{0.873}{0.184}{0.997}{0.115}{0.463}{KeyExtenderSimpleLinear na omezený automat s dosahem dvou polí}{Lwide}

\radar{0.872}{0.183}{0.997}{0.113}{0.463}{KeyExtenderSimpleLinear na cyklický automat s dosahem dvou polí}{Lcycl}

\radar{0.791}{0.811}{0.975}{0.883}{0.450}{KeyExtenderSimpleLinear na Amoeba Universe}{Lamoe}

Kombinace jednoduchého algoritmu a automatu s jednoduchým chováním vede pochopitelnì ke špatným výsledkùm (viz obrázek \ref{L220}). Ovšem výsledky automatu, který na vstupu s jedinou jednièkou generuje fraktály, není tak špatný (viz obrázek \ref{L90}). Pøíjemným pøekvapením je ovšem výsledek 2D automatu Amoeba Universe (viz \ref{Lamoe}), který v testu komprese dosahuje výsledku pøes 0,8 (zatímco 1D automaty nepøesáhly hodnotu 0,2).



\section{KeyExtenderInterlaced}

KeyExtenderInterlaced generuje výstupní klíè z obecnì vìtšího poètu stavù. Tento algoritmus se tváøí jako kompromis mezi pøedchozími dvìma algoritmy, ale blíží se spíše variantì KeyExtenderSimpleLinear. Algoritmus je parametrizován poètem øad $p$, ze kterých má dlouhý klíè generovat, a údajem $q$, kolik krokù navíc má automat vždy provést mezi generováním využívaných stavù. Pokud se spustí s parametry $p=2$, $q=0$, potom generuje totožný klíè jako lineární algoritmus. Jeho èasová složitost je lineární ve velikosti vstupu a ještì lineární v souèinu $p(q+1)$.

\radar{0.220}{0.006}{0.540}{0.022}{0.063}{KeyExtenderInterlaced(10, 0) na automat 220}{I220}

\radar{0.641}{0.513}{0.971}{0.376}{0.425}{KeyExtenderInterlaced(10, 0) na automat 94}{I94}

\radar{0.983}{0.993}{1.000}{0.519}{0.775}{KeyExtenderInterlaced(10, 0) na automat 90}{I90}

\radar{0.977}{0.985}{0.999}{0.744}{0.463}{KeyExtenderInterlaced(10, 0) na automat 30}{I30}

\radar{0.972}{0.986}{0.990}{0.653}{0.463}{KeyExtenderInterlaced(10, 0) na automat 110}{I110}

Jaké máme oèekávání od tohoto algoritmu? Vzdálenost výstupù pøi zmìnì jednoho bitu vstupu se zvýší oproti jednoduché lineární variantì a toto zlepšení bude tím vyšší, èím vìtší budou hodnoty $p, q$. U velmi špatných automatù, kde pøechodová funkce neustále snižuje pùvodní náhodnost vstupu, zpùsobí problémy vyšší poèet provedených krokù a dojde k výraznému snížení všech 5 mìøených velièin.

Zamìøme se ještì na volení hodnot argumentù $p, q$. Velké hodnoty znamenají hodnì krokù automatu. Všeobecnì se zdá být lepší zvyšovat $p$, aby se na výstupu podílelo více rùzných stavù automatu. Nejmenší možná hodnota $p=2$ není vhodná ani pøi vysokém $q$, protože vede ke ètení souvislého bloku bunìk automatu a tudíž lze ze znalosti první poloviny klíèe snadno vypoèítat druhou polovinu klíèe. Tím má smysl se znepokojovat! Pokud by útoèník zachytil ciphertext a uhodl první polovinu zprávy, tak ví i první polovinu klíèe, z ní dokáže spoèítat druhou polovinu klíèe a tím rozluští neznámou druhou polovinu zprávy \footnote{Z tohoto dùvodu také provádíme jak u algoritmu KeyExtenderSimpleLinear i u algoritmu KeyExtenderInterlaced jeden krok automatu ještì pøed prvním ètením hodnot. Kdybychom nejprve èetli stav a pak až provedli krok a volali bychom DoubleKey tøeba 2x za sebou, abychom klíè natáhli na ètyønásobek (typicky to bude ještì mnohem vìtší poèet!), tak už by útoèníkovi staèilo uhodnout jen první ètvrtinu zprávy, aby byl schopen rozluštit celou zprávu. Pokud ale nejprve provedeme krok automatu, tak útoèník sice z první ètvrtiny klíèe mùže spoèítat tøetí ètvrtinu klíèe, ale pro dopoèítání druhé ètvrtiny klíèe by musel první krok druhého volání DoubleKey invertovat, což je málo kdy možné.}. Tato neøest by se mohla projevit v testu komprese, protože pokud je kompresní algoritmus dost chytrý, tak by mohl zmenšit výstup až na polovinu. Stejná výtka platí pro KeyExtenderSimpleLinear. Když ovšem použijeme z jednoho øádku ménì hodnot, tak se dopoèítání celého stavu silnì komplikuje, pøestože budeme mít údaje o celkovì vyšším poètu øádkù. Jinými slovy, pro $p > 3$ je šíøka použitého automatu vìtší než velikost výstupu, takže poèet logických promìnných, které by musel útoèník dopoèítat, je ostøe vyšší než poèet \uv{rovnic} (vztahù výrokové logiky), které mùže využít. To samozøejmì není žádný dùkaz, protože pro nìkteré automaty bude možné i z malého poètu bitù, které jsou nìjak vybrány z rùzných stavù, dopoèítat celý stav automatu. Zvyšování hodnoty $q$ tuto výhodu neposkytuje, ale vztahy mezi jednotlivými použitými stavy jsou alespoò o dost komplikovanìjší.

Pro generování výsledkù jsme zvolili hodnoty $p = 10, q = 0$. Ve srovnání s KeyExtenderSimpleLinear vede prokládání u mnoha automatù ke znatelnému zlepšení chování (týká se to všech èi vìtšiny elementárních CA a nejvíce je to vidìt na pøíkladu pravidla 110, viz \ref{I110}), u jiných k výraznému zhoršení chování (zde viz \ref{Iamoe}).

\radar{0.971}{0.980}{0.998}{0.862}{0.463}{KeyExtenderInterlaced(10, 0) na omezený automat s dosahem dvou polí}{Iwide}

\radar{0.975}{0.984}{1.000}{0.863}{0.463}{KeyExtenderInterlaced(10, 0) na cyklický automat s dosahem dvou polí}{Icycl}

\radar{0.520}{0.528}{0.924}{0.804}{0.231}{KeyExtenderInterlaced(10, 0) na Amoeba Universe}{Iamoe}

\section{KeyExtenderUncertain}

Tento algoritmus øeší èastou neøest (prohøešek proti pseudonáhodnosti), kterou vykazují celulární automaty -- rùzný poèet 0 a 1. Algoritmus zase využívá celý stav automatu. Jsou èteny vždy dvojice bitù, pøièemž dvojice 00 a dvojice 11 jsou zahazovány. Vždy, když algoritmus narazí na dvojici 01, tak pošle na výstup 0. A za každou dvojici 10 pošle na výstup 1. Jedná se o známý trik, který se bìžnì používá tøeba u hardwarových generátorù náhodných èísel, u nichž sice nedochází k periodickému opakování stejných sekvencí, ale obèas bývá problém (tøeba v dùsledku stárnutí senzorù) s rozdílnou èetností bitù.

\radar{0.000}{0.000}{0.000}{0.000}{0.000}{KeyExtenderUncertain na automat 220}{U220}

\radar{0.000}{0.000}{0.000}{0.086}{0.475}{KeyExtenderUncertain na automat 94}{U94}

\radar{0.494}{0.499}{0.999}{0.881}{0.631}{KeyExtenderUncertain na automat 90}{U90}

\radar{0.479}{0.487}{1.000}{0.903}{0.631}{KeyExtenderUncertain na automat 30}{U30}

\radar{0.459}{0.456}{1.000}{0.948}{0.463}{KeyExtenderUncertain na automat 110}{U110}

Poèet krokù automatu, který bude algoritmus muset provést, není pøedem známý. Pokud se automat zasekne ve stavu, ze kterého není úniku (napøíklad samé nuly u mnoha druhù automatù, nebo také støídání 001100110011..001100 u elementárního automatu, který používá jako pøechodovou funkci majorantu buòky a jejich tìsných sousedù), je vyhozena výjimka. Pøípady, kdy se generování dlouhého klíèe nepodaøilo dokonèit, jsou zaøazeny do výsledkù s hodnotou 0 u všech testù.

Oèekávali jsme, že tento postup zvýší entropii výstupù, protože více vyrovná èetnost 0 a 1. Samozøejmì to nemùže fungovat vždy, protože napøíklad elementární automat èíslo 90 mùže dojít do stavu, který obsahuje dlouhý úsek pravidelného støídání 010101..0101, který se pøetvoøí na souvislý úsek samých nul a entropie je tím ještì nižší. A taky jsme se trochu obávali, že se program \uv{zasekne}, když bude pøíliš malá èást automatu \uv{živá} pro generování bitù na výstup, ale bude dlouho trvat, než automat dospìje do koneèného nemìnného stavu.

Z výsledkù se dozvídáme, že tento netradièní zpùsob ètení hodnot vedl v pár pøípadech k dobrému chování (tøeba na obrázku \ref{U90}). Vìtšinou ale špatnì dopadal test entropie (hùøe než u KeyExtenderSimpleLinear).

\radar{0.474}{0.483}{0.999}{0.964}{0.463}{KeyExtenderUncertain na omezený automat s dosahem dvou polí}{Uwide}

\radar{0.474}{0.484}{0.997}{0.995}{0.475}{KeyExtenderUncertain na cyklický automat s dosahem dvou polí}{Ucycl}

\section{KeyExtenderGenetic}

Nejkomplikovanìjší algoritmus, který tato práce obsahuje. Jako u mnoha jiných algoritmù i zde se klíè postupnì natahuje na dvojnásobek, než dosáhne dostateèné délky, ale každý krok mùže používat jiný druh automatu a jiný dílèí algoritmus. 

Ke zjištìní správné posloupnosti tìchto natahovaèù je použit genetický algoritmus. Ten tuto posloupnost optimalizuje vždy pro jeden konkrétní vstup. Fitness funkcí je aritmetický prùmìr z testù entropie a komprese.

Na zaèátku je vygenerována náhodná populace, kde jedinci jsou sekvence natahovaèù (prvky sekvence jsou instance KeyExtenderAbstractD s již pøidìlenými binárními automaty a celá sekvence je dlouhá $\lceil \log_2 {\frac{novaDelka}{puvodniDelka}} \rceil$), iniciálnì vybrána náhodnì. Pak je provedena øada iterací, která se skládá z turnajové selekce a genetických operátorù. Na konci iterace je celá pùvodní populace nahrazena novou populací. Nejlepší jedinec z prùbìhu bìhu celého algoritmu je zapamatován a lze k nìmu pøistoupit i po dokonèení generování dlouhé sekvence.

Jsou použity dva genetické operátory. Prvním je jednoduché køížení (One-point crossover) a druhým je náhodná mutace (výmìna právì jednoho natahovaèe v sekvenci za náhodný). Pravdìpodobnost køížení a pravdìpodobnost mutace je dána konstantou v~kódu, kterou mùžete zmìnit. Stejnì tak lze zmìnit velikost populace, poèet iterací a selekèní tlak.

Ve tøídì KeyExtenderGenetic se používá samostatný generátor pseudonáhodných èísel (jehož seed je pevnì daný) k provádìní všech operací, díky èemuž je pro stejný vstup možné vždy znovu vygenerovat stejný výstup na stranì odesílatele i pøíjemce zprávy. To je velmi výhodné, protože tak není potøeba použitou sekvenci automatù kódovat na zaèátek zašifrovaného souboru. To šetøí práci programátora, pøenosové pásmo i informaci, která by mohla potenciálnì vyzradit nìco o šifrovacím klíèi. 

Zbývá urèit, co má být tím náhodným natahovaèem... Program obsahuje dvì varianty tohoto: vnitøní tøídy Primitives a GoodPrimitives, které obì implementují vnitøní rozhraní IPrimitives. Tøída Primitives je implementována jako singleton. Pøi prvním vytvoøení se nejprve vygeneruje seznam binárních CA, které mohou být použity. Do seznamu je zaøazeno všech 256 elementárních CA, dále 3 druhy 2D totalistických CA (Game of Life, Amoeba Universe a Replicator Universe) a k tomu 200 kusù náhodnì vygenerovaných 1D automatù s pøechodovou funkcí využívající buòku, její sousedy a sousedy sousedù (z toho 100 je na omezeném høišti a dalších 100 na zacykleném høišti). Dílèí algoritmy pro jednotlivé kroky jsou vybírány jen z tìch, které mají lineární èasovou složitost. S každým z výše uvedených binárních CA je vytvoøen 1 KeyExtenderSimpleLinear a 6 rùzných KeyExtenderInterlaced.

Tøída GoodPrimitives funguje jinak. Nejprve jsou vygenerována data o úspìšných natahovaèích a použitých automatech bìhem èetných bìhù genetického algoritmu s využitím tøídy Primitives. Za tímto úèelem byl mnohokrát spuštìn genetický algoritmus na náhodné klíèe o velikosti 100, které natahoval na velikost 25000. Z každého bìhu genetického algoritmu byla uložena vítìzná sekvence uložena do souboru. Celkem ten experiment bìžel pøes 100 hodin. Teï je možné vytvoøit instanci tøídy GoodPrimitives, která naète tyto natahovaèe s jejich automaty z urèené složky a pak poskytuje právì takto získané natahovaèe.

Od genetického algoritmu jsme si slibovali, že najde jednoznaènì nejlepší zpùsob natažení klíèe ze všech algoritmù. Pokud by to totiž bylo výhodné, tak by i genetický algoritmus nalezl sekvenci, kde každé zdvojení klíèe provede stejný automat stejným zpùsobem. Zdá se být, že nejdùležitìjší pro kvalitu výstupu je poslední zdvojení klíèe v øadì. Pro hledání nejvhodnìjšího algoritmu na zakonèení sekvence je dùležitá mutace, køížení zde moc nepomáhá.

Nakonec jsme zjistili, že genetický algoritmus sice vytvoøí nejlepší výstup ze všech, ale potøebuje na to velkou populaci a mnoho generací, takže èasová složitost je znaènì vysoká. Kvùli ní taky nebylo možné otestovat všechny vlastnosti algoritmù, které jsme testovali pøedtím, napøíklad prùmìrnou zmìnu výstupu pøi zmìnì jednoho bitu na vstupu. Byly provádìny experimenty, bìhem kterých byly mìnìny pravdìpodobnosti jednotlivých operátorù i selekèní tlak, ale na výsledek to témìø nemìlo vliv.