
%%% Zpùsoby protahování klíèù

\chapter{Protahování klíèù pomocí celulárních automatù}

V rámci práce na roèníkovém projektu byla vytvoøena øada rùznıch celulárních automatù (potomci abstraktní tøídy CellularAutomaton), viz vıše. Vìtšina z nich je binárních (tj. kadá buòka mùe nabıvat jen dvou rùznıch stavù) a ty zároveò implementují rozhraní IBinaryCA, které vynucuje vìtšinu pro nás uiteènıch metod.

V rámci bakaláøské práce byly vytvoøeny algoritmy na protahování klíèù, které binární celulární automaty vyuívají. Všechny tyto algoritmy implementují rozhraní IKeyExtender. Toto rozhraní obsahuje metodu DoubleKey pro vytvoøení klíèe s pøesnì dvojnásobnou délkou a metodu ExtendKey pro nataení klíèe na libovolnou zadanou délku. Vstupy i vıstupy musí bıt typu BitArray, co je pole logickıch hodnot, které však v 1 bytu ukládá 8 hodnot (narozdíl od bool[~]).

Pøi vytváøení instancí tøíd implementující IKeyExtender se skrze konstruktor vkládá dovnitø libovolná implementace IBinaryCA. To umoòuje zvolit si zvláš druh automatu, kterı urèuje fungování pøechodové funkce, a zvláš protahovací algoritmus, kterı urèuje zpùsob ètení hodnot z automatu a jejich vyuití. Jedná se tedy o techniku \uv{Inversion of control}. To se hodí, abychom mohli snadno zkoušet všechny moné zpùsoby protahování klíèù. Pokud je dovnitø algoritmu vloen 2D automat, pak se stejnì indexuje jednorozmìrnì (pøi ètení hodnot ze stavu je opravdu jedno, jak funguje automat).

\begin{figure}
\centering
\includegraphics[width=107mm, height=39mm]{diagramKEAN.png}
\caption{KeyExtenderAbstractN}
\label{kean}
\end{figure}

Nìkteré z algoritmù pøímo generují dlouhı klíè zadané délky -- ty dìdí od abstraktní tøídy KeyExtenderAbstractN (viz \ref{kean}). Tato tøída pøekládá volání DoubleKey na volání ExtendKey a potomci této tøídy implementují pouze ExtendKey. Jiné algoritmy vdy prodlouí klíè na dvojnásobek a obecné nataení realizují iterací tohoto postupu -- ty jsou odvozené od abstraktní tøídy KeyExtenderAbstractD (viz \ref{kead}). Ta realizuje metodu ExtendKey pomocí logaritmického poètu volání DoubleKey a oøezává vısledek na správnou velikost. Potomci této tøídy implementují ji pouze DoubleKey.

\begin{figure}
\centering
\includegraphics[width=144mm, height=39mm]{diagramKEAD.png}
\caption{KeyExtenderAbstractD}
\label{kead}
\end{figure}

Kromì opravdovıch algoritmù byly vytvoøeny ještì dva falešné algoritmy pro úèely demonstrace, nakolik jsou kritické naše testovací metody. KeyExtenderCopy jen kopíruje kratší klíè dokola. Jeho vısledek znázoròuje obrázek \ref{copy}. KeyExtenderCheating vylosuje pseudonáhodnout posloupnost bez ohledu na vstup. Jak hezky vypadá vısledek podvodného generátoru, si mùete prohlédnout na obrázku \ref{cheat}.

\radar{0.659}{0.022}{0.997}{0.020}{0.125}{KeyExtenderCopy}{copy}

\radar{0.984}{0.993}{1.000}{1.000}{0.775}{KeyExtenderCheating}{cheat}

\section{KeyExtenderQuadratic}

Stephen Wolfram popisuje (viz \citep{W02}, strana 30), e kdy se pouije elementární automat èíslo 30 na pole obsahující jednu 1 uprostøed (jinak samé 0) a sleduje se, jak se mìní prostøední buòka v èase (podobnì jako na obrázku \ref{ca30}), tak její vıvoj je perfektní pseudonáhodnou posloupností (splòující všechny testy pseudonáhodnosti, které vyzkoušel). To nás vede k otázce, jestli by z jinıch poèáteèních stavù vznikly jiné kvalitní pseudonáhodné posloupnosti. Wolfram dále ukazuje ukazuje (viz \citep{W02}, strana 251), e kdy na pseudonáhodném vstupu (poèáteèním stavu) automatu 30 zmìní jedinı bit, tak se zmìna propaguje dolù a doprava, ale doleva se témìø nepropaguje. To zøejmì nebude platit zcela obecnì, protoe tøeba pro zmìnu samıch 0 na jednu 1 dojde ke zmìnì, která se šíøí do všech stran maximální rychlostí. Jeví se proto jako pravdìpodobné, e vıvoj prostøední buòky automatu 30 je ovlivnìn postupnì všemi buòkami nalevo a minimálnì nìkterımi buòkami napravo.

A teï u k vlastnímu algoritmu:  Nejprve je vytvoøen celulární automat, kterı je dva a pùl krát širší, ne délka krátkého klíèe. Ten krátkı klíè uloí do jeho prostøedních bunìk. Tedy klíè délky $n$ se uloí do stavu automatu s $2,5n$ buòkami a to od $0,75n$ po $1,75n$. Pak automat udìlá $2n$ krokù. Vıstup se ète z prostøední buòky (1 bit po kadém kroku automatu). Pùvodní návrh pouíval nekoneènou plochu, ale protoe nám staèí nataení na $2n$, tak plocha o šíøce $2,5n$ funguje stejnì, jako kdyby se automat mohl rozpínat do nekoneèna (efekt okraje se u nestaèí promítnout do stavu prostøední buòky).

Je jisté, e vısledky testù budou silnì záviset na pouitém celulárních automatu. Napøíklad pokud podkladovı automat vykazuje vìtší èetnost 1 ne 0 (èi naopak), tak tím pravdìpodobnì budou negativnì ovlivnìny vısledky všech testù a o vìtšinì z testù (Entropy, Compress, AveDistan, BitChange) se také dá snadno ukázat, e se ani optimální hodnotì pøi nevyrovnanıch èetnostech 0 a 1 nemohou blíit.

Vidíme, e pouití automatù s monotónním chováním vede k pøíšernì špatnım vısledkùm (napøíklad viz \ref{Q220}). Automaty s fraktálním chováním na tom také nejsou dobøe (tøeba viz \ref{Q90}), ale automat èíslo 30, kterı vykazuje pseudonáhodné chování, dává opravdu vynikající vısledek (viz \ref{Q30}). Pouití náhodného (i kdy jinak kvalitnì zvoleného) automatu s 2-okolím vede jen k prùmìrnému vısledku (jako tøeba na obrázku \ref{Qwide}). Celkovì mùeme dospìt k závìru, e chování algoritmu pro správnì zvolené automaty (napøíklad ten 30) je velmi uspokojivé, ale jeho kvadratická èasová sloitost ho èiní nepouitelnım pro šifrování delších souborù (aby vznikl dostateènı one-time pad pro zašifrování 1MB velkého souboru, tak bychom museli provést 8 milionù krokù automatu, co pøedstavuje $1,6 \cdot 10^{14}$ vyvolání pøechodové funkce, co by na dnešních procesorech trvalo øádovì jeden den).

\radar{0.000}{0.000}{0.653}{0.020}{0.000}{KeyExtenderSimpleQuadratic na automat 220}{Q220}

\radar{0.043}{0.005}{0.972}{0.046}{0.350}{KeyExtenderSimpleQuadratic na automat 94}{Q94}

\radar{0.683}{0.277}{0.512}{0.249}{0.000}{KeyExtenderSimpleQuadratic na automat 90}{Q90}

\radar{0.983}{0.993}{1.000}{0.856}{0.631}{KeyExtenderSimpleQuadratic na automat 30}{Q30}

\radar{0.634}{0.096}{0.988}{0.835}{0.450}{KeyExtenderSimpleQuadratic na automat 110}{Q110}

\radar{0.789}{0.684}{0.799}{0.797}{0.400}{KeyExtenderSimpleQuadratic na omezenı automat s 2-okolím}{Qwide}

\radar{0.789}{0.679}{0.818}{0.736}{0.400}{KeyExtenderSimpleQuadratic na cyklickı automat s 2-okolím}{Qcycl}

\section{KeyExtenderSimpleLinear}

Nejjednodušší zpùsob, jak natáhnout klíè na dvojnásobek. Tento algoritmus pouije vstup jako poèáteèní konfiguraci celulárního automatu. Pak udìlá krok a uloí jeho stav do první poloviny dlouhého klíèe (postupnì ze všech bunìk). Pak udìlá druhı krok a naète druhou polovinu dlouhého klíèe.  Pøi pouití elementárního automatu èíslo 204 jeho chování degeneruje na kopírování hodnot (stejnı vıstup jako KeyExtenderCopy), ale tím se zabıvat nebudeme. Pøi pouití automatu èíslo 51 je druhá polovina vıstupu pøesnou negací první poloviny vıstupu, co je stejnì tak nezajímavé.

Od tohoto algoritmu nemùeme èekat moc krásné chování. Napøíklad pøi jeho aplikaci s elementárním automatem za úèelem nataením klíèe na dvojnásobek dochází k tomu, e kdy zmìníme 1 bit na vstupu, nemùe se zmìnit více ne 8 bitù na vıstupu (a konkrétní podoba této zmìny je urèena jen 9 sousedními buòkami v pùvodním stavu). Pro 2D automaty nebo automaty vyuívající v pøechodové funkci vìtší okolí budou sice tato èísla vyšší, ale stále to budou nìjaké konstanty, které nezávisí na velikosti klíèe.

Kombinace jednoduchého algoritmu a automatu s jednoduchım chováním vede pochopitelnì ke špatnım vısledkùm (viz obrázek \ref{L220}). Ovšem vısledky automatu, kterı na vstupu s jedinou jednièkou generuje fraktály, není tak špatnı (viz obrázek \ref{L90}). Pøíjemnım pøekvapením je ovšem vısledek 2D automatu Amoeba Universe (viz \ref{Lamoe}), kterı v testu komprese dosahuje vısledku pøes 0,8 (zatímco 1D automaty nepøesáhly hodnotu 0,2).

\radar{0.548}{0.024}{0.771}{0.022}{0.075}{KeyExtenderSimpleLinear na automat 220}{L220}

\radar{0.608}{0.079}{0.978}{0.062}{0.450}{KeyExtenderSimpleLinear na automat 94}{L94}

\radar{0.904}{0.183}{0.999}{0.062}{0.788}{KeyExtenderSimpleLinear na automat 90}{L90}

\radar{0.894}{0.172}{0.997}{0.084}{0.463}{KeyExtenderSimpleLinear na automat 30}{L30}

\radar{0.857}{0.174}{0.995}{0.076}{0.438}{KeyExtenderSimpleLinear na automat 110}{L110}

%00010010111111001100100010011110
\radar{0.873}{0.184}{0.997}{0.115}{0.463}{KeyExtenderSimpleLinear na omezenı automat s 2-okolím}{Lwide}

\radar{0.872}{0.183}{0.996}{0.117}{0.450}{KeyExtenderSimpleLinear na cyklickı automat s 2-okolím}{Lcycl}

\radar{0.791}{0.811}{0.975}{0.883}{0.450}{KeyExtenderSimpleLinear na Amoeba Universe}{Lamoe}



\section{KeyExtenderInterlaced}

KeyExtenderInterlaced generuje vıstupní klíè z obecnì vìtšího poètu stavù. Tento algoritmus se tváøí jako kompromis mezi pøedchozími dvìma algoritmy, ale blíí se spíše variantì KeyExtenderSimpleLinear. Algoritmus je parametrizován poètem øad $p$, ze kterıch má dlouhı klíè generovat, a údajem $q$, kolik krokù navíc má automat vdy provést mezi generováním vyuívanıch stavù. Pokud se spustí s parametry $p=2$, $q=0$, potom generuje totonı klíè jako lineární algoritmus. Jeho èasová sloitost je lineární ve velikosti vstupu a ještì lineární v souèinu $p(q+1)$.

Jaké máme oèekávání od tohoto algoritmu? Vzdálenost vıstupù pøi zmìnì jednoho bitu vstupu se zvıší oproti jednoduché lineární variantì a toto zlepšení bude tím vyšší, èím vìtší budou hodnoty $p, q$. U velmi špatnıch automatù, kde pøechodová funkce neustále sniuje pùvodní náhodnost vstupu, zpùsobí problémy vyšší poèet provedenıch krokù a dojde k vıraznému sníení všech 5 mìøenıch velièin.

Zamìømì se ještì na volení hodnot argumentù $p, q$. Velké hodnoty znamenají hodnì krokù automatu. Všeobecnì se zdá bıt lepší zvyšovat $p$, aby se na vıstupu podílelo více rùznıch stavù automatu. Nejmenší moná hodnota $p=2$ není vhodná ani pøi vysokém $q$, protoe vede ke ètení souvislého bloku bunìk automatu a tudí lze ze znalosti první poloviny klíèe snadno vypoèítat druhou polovinu klíèe. Tím má smysl se znepokojovat! Pokud by útoèník zachytil ciphertext a uhodl první polovinu zprávy, tak ví i první polovinu klíèe, z ní dokáe spoèítat druhou polovinu klíèe a tím rozluští neznámou druhou polovinu zprávy \footnote{Z tohoto dùvodu také provádíme jak u algoritmu KeyExtenderSimpleLinear i u algoritmu KeyExtenderInterlaced jeden krok automatu ještì pøed prvním ètením hodnot. Kdybychom nejprve èetli stav a pak a provedli krok a volali bychom DoubleKey tøeba 2x za sebou, abychom klíè natáhli na ètyønásobek (typicky to bude ještì mnohem vìtší poèet!), tak u by útoèníkovi staèilo uhodnout jen první ètvrtinu zprávy, aby byl schopnen rozluštit celou zprávu. Pokud ale nejprve provedeme krok automatu, tak útoèník sice z první ètvrtiny klíèe mùe spoèítat tøetí ètvrtinu klíèe, ale pro dopoèítání druhé ètvrtiny klíèe by musel první krok druhého volání DoubleKey invertovat, co je málo kdy moné.}. Tato neøest by se mohla projevit v testu komprese, protoe pokud je kompresní algoritmus dost chytrı, tak by mohl zmenšit vıstup a na polovinu. Stejná vıtka platí pro KeyExtenderSimpleLinear. Kdy ovšem pouijeme z jednoho øádku ménì hodnot, tak se dopoèítání celého stavu silnì komplikuje, pøestoe budeme mít údaje o celkovì vyšším poètu øádkù. Jinımi slovy, pro $p > 3$ je šíøka pouitého automatu vìtší ne velikost vıstupu, take poèet logickıch promìnnıch, které by musel útoèník dopoèítat, je ostøe vyšší ne poèet \uv{rovnic} (vztahù vırokové logiky), které mùe vyuít. To samozøejmì není ádnı dùkaz, protoe pro nìkteré automaty bude moné i z malého poètu bitù, které jsou nìjak nasamplované z rùznıch stavù, dopoèítat celı stav automatu. Zvyšování hodnoty $q$ tuto vıhodu neposkytuje, ale vztahy mezi jednotlivımi pouitımi stavy jsou alespoò o dost komplikovanìjší.

Pro generování vısledkù jsme zvolili hodnoty $p = 10, q = 0$. Ve srovnání s KeyExtenderSimpleLinear vede prokládání u mnoha automatù ke znatelnému zlepšení chování (tıká se to všech èi vìtšiny elementárních CA a nejvíce je to vidìt na pøíkladu pravidla 110, viz \ref{I110}), u jinıch k vıraznému zhoršení chování (zde viz \ref{Iamoe}).

\radar{0.220}{0.006}{0.540}{0.022}{0.063}{KeyExtenderInterlaced(10, 0) na automat 220}{I220}

\radar{0.641}{0.513}{0.971}{0.376}{0.425}{KeyExtenderInterlaced(10, 0) na automat 94}{I94}

\radar{0.983}{0.993}{1.000}{0.519}{0.775}{KeyExtenderInterlaced(10, 0) na automat 90}{I90}

\radar{0.977}{0.985}{0.999}{0.744}{0.463}{KeyExtenderInterlaced(10, 0) na automat 30}{I30}

\radar{0.972}{0.986}{0.990}{0.653}{0.463}{KeyExtenderInterlaced(10, 0) na automat 110}{I110}

\radar{0.971}{0.980}{0.998}{0.862}{0.463}{KeyExtenderInterlaced(10, 0) na omezenı automat s 2-okolím}{Iwide}

\radar{0.971}{0.980}{0.999}{0.881}{0.463}{KeyExtenderInterlaced(10, 0) na cyklickı automat s 2-okolím}{Icycl}

\radar{0.520}{0.528}{0.924}{0.804}{0.231}{KeyExtenderInterlaced(10, 0) na Amoeba Universe}{Iamoe}

\section{KeyExtenderUncertain}

Tento algoritmus øeší èastou neøest (prohøešek proti pseudonáhodnosti), kterou vykazují celulární automaty -- rùznı poèet 0 a 1. Algoritmus zase vyuívá celı stav automatu. Jsou èteny vdy dvojice bitù, pøíèem dvojice 00 a dvojice 11 jsou zahazovány. Vdy, kdy algoritmus narazí na dvojici 01, tak pošle na vıstup 0. A za kadou dvojici 10 pošle na vıstup 1. Poèet krokù automatu, kterı bude algoritmus muset provést, není pøedem známı. Pokud se automat zasekne ve stavu, ze kterého není úniku (napøíklad samé nuly u mnoha druhù automatù, nebo také støídání 001100110011..001100 u elementárního automatu, kterı pouívá jako pøechodovou funkci majorantu buòky a jejich tìsnıch sousedù), je vyhozena vıjimka. Pøípady, kdy se generování dlouhého klíèe nepodaøilo dokonèit, jsou zaøazeny do vısledkù s hodnout 0 u všech testù.

Oèekávali jsme, e tento postup zvıší entropii vıstupù, protoe více vyrovná èetnost 0 a 1. Samozøejmì to nemùe fungovat vdy, protoe napøíklad elementární automat èíslo 90 mùe dojít do stavu, kterı obsahuje dlouhı úsek pravidelného støídání 010101..0101, kterı se pøetvoøí na souvislı úsek samıch nul a entropie je tím ještì niší. A taky jsme se trochu obávali, e se program \uv{zasekne}, kdy bude pøíliš malá èást automatu \uv{ivá} pro generování bitù na vıstup, ale bude dlouho trvat, ne automat dospìje do koneèného nemìnného stavu.

Z vısledkù se dozvídáme, e tento netradièní zpùsob ètení hodnot vedl v pár pøípadech k dobrému chování (tøeba na obrázku \ref{U90}). Vìtšinou ale špatnì dopadal test entropie (hùøe ne u KeyExtenderSimpleLinear).

\radar{0.000}{0.000}{0.000}{0.000}{0.000}{KeyExtenderUncertain na automat 220}{U220}

\radar{0.490}{0.063}{0.000}{0.858}{0.294}{KeyExtenderUncertain na automat 94}{U94}

\radar{0.909}{0.513}{1.000}{0.879}{0.631}{KeyExtenderUncertain na automat 90}{U90}

\radar{0.473}{0.481}{0.992}{0.900}{0.300}{KeyExtenderUncertain na automat 30}{U30}

\radar{0.621}{0.449}{1.000}{0.914}{0.294}{KeyExtenderUncertain na automat 110}{U110}

\radar{0.615}{0.481}{1.000}{0.943}{0.294}{KeyExtenderUncertain na omezenı automat s 2-okolím}{Uwide}

\radar{0.615}{0.482}{0.999}{0.943}{0.319}{KeyExtenderUncertain na cyklickı automat s 2-okolím}{Ucycl}

\section{KeyExtenderGenetic}

Nejkomplikovanìjší algoritmus, kterı tato práce obsahuje. Jako u mnoha jinıch algoritmù i zde se klíè postupnì natahuje na dvojnásobek, ne dosáhne dostateèné délky, ale kadı krok mùe pouívat jinı druh automatu a jinı dílèí algoritmus. 

Ke zjištìní správné posloupnosti tìchto natahovaèù je pouit genetickı algoritmus. Ten tuto posloupnost optimalizuje vdy pro jeden konkrétní vstup. Fitness funkcí je aritmetickı prùmìr z testù entropie a komprese.

Na zaèátku je vygenerována náhodná populace, kde jedinci jsou sekvence natahovaèù (prvky sekvence jsou instance KeyExtenderAbstractD s ji pøidìlenımi binárními automaty a celá sekvence je dlouhá $\lceil \log_2 {\frac{novaDelka}{puvodniDelka}} \rceil$), iniciálnì vybrána náhodnì. Pak je provedena øada iterací, která se skládá z turnajové selekce a genetickıch operátorù. Na konci iterace je celá pùvodní populace nahrazena novou populací. Nejlepší jedinec z prùbìhu bìhu celého algoritmu je zapamatován a lze k nìmu pøistoupit i po dokonèení generování dlouhé sekvence.

Jsou pouity dva genetické operátory. Prvním je jednoduché køíení (One-point crossover) a druhım je náhodná mutace (vımìna právì jednoho natahovaèe v sekvenci za náhodnı). Pravdìpodobnost køíení a pravdìpodobnost mutace je dána konstantou v~kódu, kterou se klidnì cite volní zmìnit. Stejnì tak lze zmìnit velikost populace, poèet iterací a selekèní tlak.

Ve tøídì KeyExtenderGenetic se pouívá samostatnı generátor pseudonáhodnıch èísel (jeho seed je danı) k provádìní všech operací, díky èemu je pro stejnı vstup moné vdy znovu vygenerovat stejnı vıstup na stranì odesílatele i pøíjemce zprávy. To je velmi vıhodné, protoe tak není potøeba pouitou sekvenci automatù kódovat na zaèátek zašifrovaného souboru. To šetøí práci programátora, pøenosové pásmo i informaci, která by mohla potenciálnì vyzradit nìco o šifrovacím klíèi. 

Zbıvá urèit, co má bıt tím náhodnım natahahovaèem... Program obsahuje dvì varianty tohoto: vnitøní tøídy Primitives a GoodPrimitives, které obì implementují vnitøní rozhraní IPrimitives. Tøída Primitives je implementována jako singleton. Pøi prvním vytvoøení se nejprve vygeneruje seznam binárních CA, které mohou bıt pouity. Do seznamu je zaøazeno všech 256 elementárních CA, dále 3 druhy 2D totalistickıch CA (Game of Life, Amoeba Universe a Replicator Universe) a k tomu 200 kusù náhodnì vygenerovanıch 1D automatù s pøechodovou funkcí vyuívající buòku, její sousedy a sousedy sousedù (z toho 100 je na omezeném høišti a dalších 100 na zacykleném høišti). Dílèí algoritmy pro jednotlivé kroky jsou vybírány jen z tìch, které mají lineární èasovou sloitost. S kadım z vıše uvedenıch binárních CA je vytvoøen 1 KeyExtenderSimpleLinear a 6 rùznıch KeyExtenderInterlaced.

Tøída GoodPrimitives funguje jinak. Nejprve jsou vygenerována data o úspìšnıch natahovaèích a pouitıch automatech bìhem èetnıch bìhù genetického algoritmu s vyuitím tøídy Primitives. Za tímto úèelem byl mnohokrát spuštìn genetickı algoritmus na náhodné klíèe o velikosti 100, které natahoval na velikost 25000. Z kadého bìhu genetického algoritmu byla uloena ta vítìzná sekvence do souboru. Celkem ten experiment bìel pøes 100 hodin. Teï je moné vytvoøit instanci tøídy GoodPrimitives, která naète tyto natahovaèe s jejich automaty z urèené sloky a pak poskytuje právì takto získané natahovaèe.

Od genetického algoritmu jsme si slibovali, e najde jednoznaènì nejlepší zpùsob nataení klíèe ze všech algoritmù. Pokud by to toti bylo vıhodné, tak by i genetickı algoritmus nalezl sekvenci, kde kadé zdvojení klíèe provede stejnı automat stejnım zpùsobem. Zdá se bıt, e nejdùleitìjší pro kvalitu vıstupu je poslední zdvojení klíèe v øadì. Pro hledání nejvhodnìjšího algoritmu na zakonèení sekvence je dùleitá mutace, køíení zde nepomáhá.

Nakonec jsme zjistili, e genetickı algoritmus sice vytvoøí nejlepší vıstup ze všech, ale potøebuje na to velkou populaci a mnoho generací, take èasová sloitost je znaènì vysoká. Kvùli ní taky nebylo moné otestovat všechny vlastnosti algoritmù, které jsme testovali pøedtím, napøíklad prùmìrnou zmìnu vıstupu pøi zmìnì jednoho bitu na vstupu. Byly provádìny experimenty, bìhem kterıch byly mìnìny pravdìpodobnosti jednotlivıch operátorù i selekèní tlak, ale na vısledek to témìø nemìlo vliv.