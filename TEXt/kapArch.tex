\chapter{Nástin architektury}

Tato kapitola je urèitım doplòkem k vıvojové dokumentaci, která byla vytvoøena z dokumentaèních komentáøù. Tato kapitola se nesnaí nahradit ètení vıvojové dokumentace ani pøeètení ostatních kapitol této práce, ve kterıch jsou podrobnìji vysvìtleny klíèové èásti programu.

\section{Úvod k návrhu}

V rámci jednoho øešení (Solution) ve Visual Studiu byly vytvoøeny tøi projekty. Projekt se jménem MartinDvorak, kterı mìl pùvodnì bıt jedinou èástí aplikace a mìl jasnì identifikovat tuto práci pøi jejím elektronickém odevzdávání, obsahuje veškerou logiku popisovanou v textu práce. Pomocí tohoto projektu byly provádìny veškeré experimenty. Obsahuje 3 jmenné prostory (Namespace): Cellular, Crypto a Testing.

Jako druhı vznikl malı projekt se jménem Program. Ten vyuívá nástroje vytvoøené v prvním projektu a kompiluje se na WinForms aplikaci, kterou mohou uivatelé pouít k zašifrování svıch souborù. Tøetí je testovací projekt se jménem CryptographyUnitTests. Ten testuje, e šifrování funguje správnì (tj. e rozšifrování je inverzním zobrazením).

Práce neobsahuje ádné závislosti na externích knihovnách. Ke spuštìní staèí mít nainstalován .NET framework verze 4.5 (èi vyšší), kterı je automatickou souèástí operaèního systému Windows 8 (èi novìjší), ale mùe se nacházet i na starších verzích (já ho mám na Windows 7).

Pøi vıvoji byl kladen dùraz na znovupouitelnost kódu. To bylo dùleité, protoe v prùbìhu programování ještì nebylo jasné, jakım zpùsobem se bude vyuívat kterı automat èi algoritmus. Znovupouitelnost je dosahována pomocí kvalitního objektového návrhu, vìtšího mnoství variant konstruktorù a propojování objektù prostøednictvím rozhraní. Stìejní trojice rozhraní je uvedena na obrázku \ref{diagramif} Dále byla vìnována pozornost vysokému vıkonu.

Dùleitá je také pøehlednost zdrojového kódu. Proto byly ke všem tøídám a ke všem jejím veøejnım metodám (a obèas i tìm ostatním) psány XML komentáøe podle zvyklostí programátorù v C\# a práce ve Visual Studiu. Z nich byla také vygenerována vıvojáøská dokumentace v HTML.

\begin{figure}
\centering
\includegraphics[width=106mm, height=60mm]{diagramIF.png}
\caption{Hlavní rozhraní v naší práci}
\label{diagramif}
\end{figure}

Ve zbytku této kapitoly popíšeme jednotlivé jmenné prostory.

\section{Cellular}

\subsection{Abstraktní tøída CellularAutomaton}

Vršek hierarchie všech celulárních automatù. Je tu jediná spoleèná datová poloka pro všechny druhy automatù – time. Je to diskrétní èas zaèínající na 0, kterı udává, kolik krokù vıpoètu ji probìhlo. Tento údaj oznamuje metoda GetTime. Dále je tu abstraktní metoda Step, která záleí na konkrétním typu automatu. Kromì zavolání Step bez parametru je moné zavolat Step s uvedením poètu, které tolikrát zavolá metodu Step. Poloku time musí updatovat metoda Step sama o sobì. Dále jsou tu abstraktní metody Clone a TellType.

CellularAutomaton má dva pøímé následníky: abstraktní tøídy Automaton1D a Automaton2D (viz obrázek \ref{diagramca}). Protoe ještì nevíme nic o konkrétním typu automatu, není tu ádná nová poloka kromì velikosti. Konkrétnì, Automaton1D má jedinou poloku size, Automaton2D má dvojici poloek width, height. Viditelnost mají protected, tudí k nim nikdo nemùu pøistupovat zvenèí pøímo.

\subsection{Koncept tøídní hierarchie}

Balíèek Cellular je navren tak, aby slouil nejen ke konkrétnímu šifrovacímu algoritmu, ale aby mohl pøijít jinı èlovìk a hrát si s celulárními automaty (a u za úèelem poznávání, nebo za úèelem generování dat pro další aplikace). Proto byla pøi implementaci snaha, aby kromì vıstupu pro poèítaè existovaly i „grafické vıstupy“ pro debugging a sledování chování automatù. Pro snadnìjší práci je obèas naimplementován i takovı typ CA, kterı se speciálním pøípadem nìjakého obecnìjšího typu CA. Pøíkladem mùe bıt imlementace elementárních 256 automatù, které staèí zadat jejich èíslem (podle Stephena Wolframa). Snaha o rozšiøitelnost se projevila rùznımi „mezitøídami“ mezi úplnì abstraktním automatem (kterı nic nespecifikuje) a konkrétní implementací konkrétního typu automatù.

\begin{figure}
\centering
\includegraphics[width=144mm, height=80mm]{diagramCA.png}
\caption{Diagram hierarchie celulárních automatù}
\label{diagramca}
\end{figure}

Tìištìm práce jsou binární automaty, protoe jsou jejich vıstupy snadno zpracovatelné a protoe je jejich chování dostateènì komplexní a rozmanité, aby dokázaly nasimulovat jakıkoliv druh automatu. Nicménì byly ve velmi omezené míøe implementovány i jiné ne binární automaty.

Abstraktní OOP pøístup pøirozenì vede k \uv{diamond inheritance problem} napøíklad mezi ètveøicí abstraktních tøíd: úplnì obecnı CA, obecnı jednorozmìrnı CA, jakıkoliv binární CA a jednorozmìrnı binární CA. Protoe C\# nepodporuje vícenásobnou dìdiènost, bylo vytvoøeno rozhraní IBinaryCA, které implementují všechny binární celulární automaty. Takovı poèin má jisté vıhody i nevıhody. Vıhodou je, e IBinaryCA je u ze sémantiky rozhraním. I kdyby byl abstraktní tøídou, nemá vlastní datové poloky ani vlastní implementaci metod, take je pouití interfacu vhodné. Nevıhodou interfacu je to, e není moné vynutit, aby rozhraní IBinaryCA implementovaly pouze podtøídy CellularAutomaton.

\subsection{Ukládání stavu celulárního automatu}

Pùvodní implementace jednorozmìrnıch binárních CA ukládala stav jako bool[~] a pro dvojrozmìrné byl datovım typem bool[,]. Ji brzy bylo jasné, e to byla dost špatná volba a na vıbìr byly dvì lepší alternativy:
\begin{itemize}
\item BitArray – buòka zabírá jen jeden bit, zatímco pøi pouití System.Boolean buòka zabírala celı byte. Pøístup k datùm je stejnı – pøes index. Akorát u dvojrozmìrnıch automatù je pouit typ BitArray[~], ke kterému se pøistupuje jako state[i][j] místo pùvodního state[i,j] a je potøeba zavolat vìtší mnoství konstruktorù.
\item byte[~] obsahující jen hodnoty 0 a 1 - stejná velikost jako pøi pouití bool[~], ale není potøeba pouívat podmínky na hodnotu pro dosazení do aritmetickıch operací (zisk indexu do pole popisujícího pøechodovou funkci èi pouhé sèítání hodnot sousedních bunìk u totalistickıch pravidel).
\end{itemize}

Nakonec byla zvolena první varianta, protoe pøi pouití CA na prodluování šifrovacích klíèù mùe bıt velikost automatu v posledních krocích vıpoètu opravdu velká. A nechceme pro šifrování souboru o velikosti 1 GB spotøebovat pøes 8 GB pamìti.

Pro N-ární automaty byl zvolen ponìkud nehospodárnı int[]. To mùe bıt do budoucna zmìnìno, pokud se bude intenzivnìji pracovat i s jinımi ne binárními automaty.

Datové poloky ukládající stav byly navrené jako immutable. Take napøíklad není problém dávat do konstruktorù pole s iniciálním stavem (pøedávané vdy referencí) bez kopírování. Kdykoliv se provádí krok CA, je vytvoøen novı vnitøní stav a po probìhnutí vıpoètu je nahrazen ukazatel na tento stav.

\subsection{Optimalizace vıpoètu elementárních automatù}

Pøi vıpoètu nového stavu ve tøídì ElementaryAutomaton se musí vdy podle stavu 3 bunìk rozhodnout stav 1 nové buòky (a novı stav se získává z trojrozmìrného pole o velikost 2x2x2). To je neefektivní, protoe poèet ètení stavu je zde tøikrát vìtší ne poèet vytváøenıch stavù. Kdykoliv se vyskytne ve stavu elementárního automatu stejnı blok, novı stav tìch bunìk v dalším kroku, kromì buòky úplnì vlevo a buòky úplnì vpravo, je vdy stejnı. Proto by se mohl uspoøit èas vıpoètu (hlavnì sníením poètu podmínìnıch skokù pøi vykonávání), kdyby se celé bloky zobrazovaly na celé bloky podle nìjaké pøedgenerované lookup tabulky. Tato optimalizace byla naimplementována v tøídì ElementaryAutomatonFast, kde bylo zvoleno mapování vdy 10 bunìk na novıch 8 bunìk. Na konci práce na roèníkovém projektu byla knihovna v tomto stavu: 256 elementární CA mohly simulovat tøi rùzné tøídy, pøièem ElementaryAutomatonFast to dìlal nejrychleji, ElementaryAutomaton støednì rychle a BinaryRangeAutomaton nejpomaleji.

Bìhem programování bakaláøské práce byla vìtšina èasu vìnována ostatním jmennım prostorùm, ale v posledních mìsících došlo i na optimalizaci vıpoètu celulárních automatù. Protoe BinaryRangeAutomaton provádìl k urèení stavu kadé nové buòky $1+2r$ ètení pøedchozích stavù, kde $r$ je poèet pouívanıch bunìk na kadou stranu, byla zvolena jiná implementace. Nyní jsou právì pøeètené buòky uloeny v èíselné promìnné (kterou lze indexovat do pole popisujícího pravidlo) a pøi pøesunu na novou buòku je èíselná hodnota pouze zdvojnásobena (s oøíznutím na správnou velikost, aby se zahodila buòka úplnì vlevo) a pøièten stav buòky úplnì vpravo. Nová implementace BinaryRangeAutomaton byla natolik rychlá, e dokonce porazila ElementaryAutomatonFast pøi simulaci elementárních automatù.

Tím jsme se pouèili pro vytvoøení ještì lepší implementace elementárních CA, která také ète kadou buòku jen jednou, prùbìnı stav uchovává v èíselné promìnné a indexuje do jednorozmìrného pole popisujícího pravidlo (rychlost nové implementace BinaryRangeAutomaton toti ukázala, e je to rychlejší ne lookup tabulka). Tato implementace by mìla kombinovat vıhodu nové implementace BinaryRangeAutomaton s vıhodou specifické implementace na pøedem známou velikost pravidla.

Byla tak vytvoøena tøída ElementaryAutomatonFaster a pak ještì její paralelní implementace ve tøídì ElementaryAutomatonParallel. Pøi paralelizaci se vyuívá toho, e BitArray je thread-safe, pokud nedochází k souèasnému zápisu z více vláken do stejné èásti, kde èásti jsou dlouhé 32 bitù a jsou zarovnané tak, jak by programátor èekal (bity 0 a 31 tvoøí první èást, bity 32 a 63 tvoøí druhou èást a tak dále). Bylo dùkladnì ovìøeno, e všechny 4 implementace elementárních CA produkují stejné vısledky.

Pøi mìøení vıkonu jsme zjistili, e ve srovnání s vıpoètem pomocí tøídy ElementaryAutomaton dosáhla implementace ElementaryAutomatonFast 86\% èasu, ElementaryAutomatonFaster dosáhl dokonce 48\% èasu, ElementaryAutomatonParallel to mìl za 75\% èasu a BinaryRangeAutomaton za pøekvapivì dobrıch 51\% èasu. Neefektivita paralelní implementace byla zklamáním. Pro malé velikosti automatu se jistì nevyplatí kvùli reii spouštìní vláken a pro velké velikosti automatu je pravdìpodobnì problém s paralelním ètením velkého mnoství dat z~pamìti (a souèasnım zápisem). Pozdìji byla provedena mìøení i na jinıch poèítaèích. Vısledky jsou vesmìs obdobné -- poøadí algoritmù podle rychlosti jsou stejná, akorát se obèas dostane ElementaryAutomatonParallel pøed ElementaryAutomatonFaster, jak jsme si pøi paralelizaci pøáli.

\section{Crypto}

Tento jmennı prostor jednak obsahuje natahovaèe klíèù (popsané v následující kapitole) a potom statistické testy (popsané v pøedchozí kapitole). Také se tu nachází reie kolem šifrování a statická tøída Factory, která nahrazuje monost deserializace CA a vìtších objektù, které je obsahují.

Natahovaèe klíèù implementují rozhraní IKeyExtender. Tøída EncrypterStreamCA umí pouít libovolnou implementaci IKeyExtender k šifrování pole bitù. Nad tou je ještì vybudovaná abstrakce v podobì rozhraní IEncrypter, které obecnì poskytuje pøístup k libovolnému symetrického kryptografickému algoritmu. Rozhraní IEncrypter ještì implementuje tøída EncrypterReversibleCA, která realizuje šifrování alternativním zpùsobem (viz poslední kapitola). 

Nad implementacemi rozhraní IEncrypter je ještì vybudována spoleèná obalová vrstva v podobì tøídy EncryptionProvider. Ta umoòuje šifrovat pøímo Streamy dat zadáním uivatelského hesla, co je pouito v praktické aplikaci. EncryptionProvider dostává IEncrypter jako parametr konstruktoru. Zašifrování dat probíhá tak, e se vygeneruje náhodnı salt pomocí kryptograficky bezpeèného generátoru pseudonáhodnıch èísel a napíše se na vıstup. Tento salt se zároveò spojí se zadanım heslem a vyrobí se z toho 128-bitovı hash, kterı slouí jako krátkı klíè pro IEncrypter. Zašifrovanı proud dat se zapíše hned za salt, protoe salt má pevnì danou délku 16 bytù. Rozšifrování probíhá tak, e uivatel zadá heslo (se kterım byl soubor zašifrován), ze zašifrovaného souboru se pøeète nejprve salt, ten se spojí se zadanım heslem a zahešuje a vısledek se pouije jako krátké heslo pro IEncrypter. Ten rozšifruje celı vstup, ze kterého ji ignoruje prvních 16 bytù (salt).

Statická tøída Export poskytuje pøístup k funkcionalitì, která má bıt pouitelná i z jiné assembly a provádí veškerou instanciaci interních tøíd, které ji není moné ovládat pøímo z vnìjšku. Napøíklad poskytuje jednu konkrétní implementaci IKeyExtender, do ní je vloen elementární automat èíslo 30 (ve zrychlené variantì). Z vnìjšku není moné vynutit jinou variantu. Dále poskytuje pøístup ke tøídì EncryptionProvider (jsou tu dvì varianty pro dva rùzné vloené šifrovací algoritmy).

\section{Testing}

Nejedná se toliko o jednotkové testy, jako spíše mnoinu pøíkladù, které zkoušejí pouívat rùzné èásti programu. Lze si zde hrát s vizualizací nìkterıch automatù.

\section{Program}

Okenní aplikace, umoòuje šifrovat a dešifrovat. V podstatì realizuje jen volbu vstupního a vıstupního souboru. O zbytek se stará projekt MartinDvorak. 

Nejvìtší moná velikost šifrovaného souboru je 128MB. Dùvodem je, e pro vìtší velikost by ji bylo potøeba pouít BitArray o velikosti 256MB a protoe se velikost zadává v poètu bitù a argument je typu int, bylo by potøeba vloit hodnotu $2^{31}$, ale nejvyšší hodnota intu je $2^{31}-1$. I kdyby nebylo nutné pouít konstruktor se zadáním pøesného poètu bitù (ale bral by tøeba poèet bytù), tak tím by int mohl slouit ještì k indexaci bitù v poli o velikosti pøesnì 256MB, ale ne vìtšího.

Limit by mohl bıt zvıšen, pokud bychom vytvoøili vlastní implementaci BitArray, která by pro urèení velikosti a indexaci pouívala typ uint, nebo ještì lépe long. Nicménì by to asi nebylo velmi uiteèné rozšíøení, protoe u šifrování souboru o velikosti 256MB trvá nìkolik minut.

\section{CryptographyUnitTests}

Zde jsou skuteèné jednotkové testy, které testují šifrovací algoritmy skrze veøejnou tøídu EncryptionProvider poskytnutou ve dvou verzích tøídou Export.