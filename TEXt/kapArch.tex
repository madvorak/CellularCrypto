\chapter{Nástin architektury}

Tato kapitola je urèitım doplòkem k vıvojové dokumentaci, která byla vytvoøena z dokumentaèních komentáøù. Tato kapitola se nesnaí nahradit ètení vıvojové dokumentace ani pøeètení ostatních kapitol této práce, ve kterıch jsou podrobnìji vysvìtleny klíèové èásti programu.

\section{Úvod k návrhu}

Celı zdrojovı kód se nachází v repozitáøi na adrese: 

\noindent https://madv.visualstudio.com/DefaultCollection/\_git/Cellular\%20Cryptography\#\_a=contents 

V rámci jedné Solution ve Visual Studiu byly vytvoøeny tøi projekty. Projekt se jménem MartinDvorak, kterı mìl pùvodnì bıt jedinou èástí aplikace a mìl jasnì identifikovat tuto práci pøi jejím elektronickém odevzdávání, obsahuje veškerou logiku popisovanou v textu práci. Pomocí tohoto projektu byly provádìny veškeré experimenty. Obsahuje 3 jmenné prostory: Cellular, Crypto a Testing.

Jako druhı vznikl malı projekt se jménem Program. Ten vyuívá nástroje vytvoøené v prvním projektu a kompiluje se na WinForms aplikaci, kterou mohou uivatelé pouít k zašifrování svıch souborù. Tøetí je testovací projekt se jménem CryptographyUnitTests. Ten testuje, e šifrování funguje správnì (rozšifrování je inverzním zobrazením).

Práce neobsahuje ádné závislosti na externích knihovnách. Ke spuštìní staèí mít nainstalován .NET framework verze 4.5 (èi vyšší), kterı je automatickou souèástí operaèního systému Windows 8 (èi novìjší), ale mùe se nacházet i na starších verzích (já ho mám na Windows 7).

Pøi vıvoji byl kladen dùraz na znovupouitelnost kódu. To bylo dùleité, protoe v prùbìhu programování ještì nebylo jasné, jakım zpùsobem se bude vyuívat kterı automat èi algoritmus. Znovupouitelnost je dosahována pomocí kvalitního objektového návrhu, vìtšího mnoství variant konstruktorù a propojování objektù prostøednictvím rozhraní. Stìejní trojice rozhraní je uvedena na obrázku \ref{diagramif} Dále byla vìnována pozornost vysokému vıkonu.

Dùleitá je také pøehlednost zdrojového kódu. Proto byly ke všem tøídám a ke všem jejím vìøejnım metodám (a obèas i tìm ostatním) psány XML komentáøe podle zvyklostí programátorù v C\# a práce ve Visual Studiu. Z nich byla také vygenerována vıvojáøská dokumentace v HTML.

\begin{figure}
\centering
\includegraphics[width=106mm, height=60mm]{diagramIF.png}
\caption{Hlavní rozhraní v naší práci}
\label{diagramif}
\end{figure}

\section{Cellular}

\subsection{Abstraktní tøída CellularAutomaton}

Vršek hierarchie všech celulárních automatù. Je tu jediná spoleèná datová poloka pro všechny druhy automatù – time. Je to diskrétní èas zaèínající na 0, kterı udává, kolik krokù vıpoètu ji probìhlo. Tento údaj oznamuje metoda GetTime. Dále je tu abstraktní metoda Step, která záleí na konkrétním typu automatu. Kromì zavolání Step bez parametru je moné zavolat Step s uvedením poètu, které tolikrát zavolá metodu Step. Poloku time musí updatovat metoda Step sama o sobì. Dále jsou tu abstraktní metody Clone a TellType.

CellularAutomaton má dva pøímé následníky: abstraktní tøídy Automaton1D a Automaton2D (viz obrázek \ref{diagramca}). Protoe ještì nevíme nic o konkrétním typu automatu, není tu ádná nová poloka kromì velikosti. Konkrétnì, Automaton1D má jedinou poloku size, Automaton2D má dvojici poloek width, height. Viditelnost mají protected, tudí k nim nikdo nemùu pøistupovat zvenèí pøímo.

\subsection{Koncept tøídní hierarchie}

Balíèek Cellular je navret tak, aby slouil nejen ke konkrétnímu šifrovacímu algoritmu, ale aby mohl pøijít jinı èlovìk a hrát si s celulárními automaty (a u za úèelem poznávání, nebo za úèelem generování dat pro další aplikace). Proto byla pøi implementaci snaha, aby kromì vıstupu pro poèítaè existovaly i „grafické vıstupy“ pro debugging a sledování chování automatù. Pro snadnìjší práci je obèas naimplementován i takovı typ CA, kterı se speciálním pøípadem nìjakého obecnìjšího typu CA. Pøíkladem mùe bıt imlementace elementární 256 automatù, které staèí zadat jejich èíslem (podle Stephena Wolframa). Snaha o rozšíøitelnost se projevila rùznımi „mezitøídami“ mezi úplnì abstraktním automatem (kterı nic nespecifikuje) a konkrétní implementací konkrétního typu automatù.

\begin{figure}
\centering
\includegraphics[width=150mm, height=80mm]{diagramCA.png}
\caption{Diagram hierarchie celulárních automatù}
\label{diagramca}
\end{figure}

Tìištìm práce jsou binární automaty, protoe jsou jejich vıstupy snadno zpracovatelné a protoe je jejich chování dostateènì komplexní a rozmanité, aby dokázaly nasimulovat jakıkoliv druh automatu. Nicménì byly ve velmi omezené míøe implementovány i jiné ne binární automaty.

Abstraktní OOP pøístup pøirozenì vede k \uv{diamond inheritance problem} napøíklad mezi ètveøicí abstraktních tøíd: úplnì obecnı CA, obecnı jednorozmìrnı CA, jakıkoliv binární CA a jednorozmìrnı binární CA. Protoe C\# nepodporuje vícenásobnou dìdiènost, bylo vytvoøeno rozhraní IBinaryCA, které implementují všechny binární celulární automaty. Takovı poèin má jisté vıhody i nevıhody. Vıhodou je, e IBinaryCA je u ze sémantiky rozhraním. I kdyby byl abstraktní tøídou, nemá vlastní datové poloky ani vlastní implementaci metod, take je pouití interfacu vhodné. Nevıhodou interfacu je, e není moné vynutit, aby rozhraní IBinaryCA implementovaly pouze podtøídy CellularAutomaton, take není moné C\# \uv{nauèit} e IBinaryCA leí v hierarchii pod CellularAutomaton.

\subsection{Ukládání stavu celulárního automatu}

Pùvodní implementace jednorozmìrnıch binárních CA ukládala stav jako bool[~] a pro dvojrozmìrné byl datovım typem bool[,]. Ji brzy bylo jasné, e to byla dost špatná volba a na vıbìr byly dvì lepší alternativy:
\begin{itemize}
\item BitArray – buòka zabírá jen jeden bit, zatímco pøi pouití System.Boolean buòka zabírala celı byte. Pøístup k datùm je stejnı – pøes index. Akorát u dvojrozmìrnıch automatù je pouit typ BitArray[~], ke kterému se pøistupuje jako state[i][j] místo pùvodního state[i,j] a je potøeba zavolat vìtší mnoství konstruktorù.
\item byte[~] obsahující jen hodnoty 0 a 1 - stejná velikost jako pøi pouití bool[~], ale není potøeba pouívat podmínky na hodnotu pro dosazení do aritmetickıch operací (zisk indexu do pole popisujícího pøechodovou funkci èi pouhé sèítání hodnot sousedních bunìk u totalistickıch pravidel).
\end{itemize}

Nakonec byla zvolena první varianta, protoe pøi pouití CA na prodluování šifrovacích klíèù mùe bıt velikost automatu v posledních krocích vıpoètu opravdu velká. A nechceme pro šifrování souboru o velikosti 1 GB spotøebovat pøes 8 GB pamìti.

Pro N-ární automaty byl zvolen ponìkud nehospodárnı int[]. To mùe bıt do budoucna zmìnìno, pokud se bude intenzivnìji pracovat i s jinımi ne binárními automaty.

Datové poloky ukládající stav byly navrené jako immutable. Take napøíklad není problém dávat do konstruktorù pole s iniciálním stavem (pøedávané vdy referencí) bez kopírování. Kdykoliv se provádí krok CA, je vytvoøen novı vnitøní stav a po probìhnutí vıpoètu je nahrazen ukazatel na tento stav.

\subsection{Optimalizace vıpoètu elementárních automatù}

Pøi bìzném vıpoètu nového stavu (ElementaryAutomaton) se musí vdy podle stavu 3 bunìk rozhodnout stav 1 nové buòky. To je mírnì neefektivní. Kdykoliv se vyskytne ve stavu elementárního automatu stejnı blok, novı stav tìch bunìk v dalším kroku, kromì buòky úplnì vlevo a buòky úplnì vpravo, je vdy stejnı. Proto by se mohl uspoøit èas vıpoètu (hlavnì sníením poètu podmínìnıch skokù pøi vykonávání), kdyby se celé bloky zobrazovaly na celé bloky podle nìjaké pøedgenerované lookup table. Tato optimalizace byla naimplementována v tøídì ElementaryFastAutomaton, kde bylo zvoleno mapování vdy 10 bunìk na novıch 8 bunìk. Starší implementace ElementaryFastAutomaton provedla stejnı vıpoèet za 62\% èasu, co potøeboval  ElementaryAutomaton. Novìjší a lepší implementace ElementaryFastAutomaton se dostala na 48\%. Pro zajímavost: vyvolání úplnì stejného vıpoètu pomocí obecnìjší tøídy BinaryRangeAutomaton trvalo 110\% èasu co obyèejnı ElementaryAutomaton. Take celkovı pomìr v efektivitì mezi tou nejspecializovanìjší a tou nejménì specifickou tøídou (která je ale stále ještì binárním CA) pro simulace základních 256 CA je asi 2,3x.

\section{Crypto}

Tento namespace jednak obsahuje natahovaèe klíèù (popsané v následující kapitole) a potom testy (popsané v pøedchozí kapitole). Také se tu nachází statická tøída Factory, která nahrazuje monost deserializace CA a vìtších objektù, které je obsahují.

Natahovaèe klíèù implementují rozhraní IKeyExtender. Tøída EncrypterStreamCA umí pouít libovolnou implementaci IKeyExtender k šifrování pole bitù. Nad tou je ještì vybudovaná abstrakce v podobì rozhraní IEncrypter, které obecnì poskytuje pøístup k libovolnému symetrického kryptografickému algoritmu. Rozhraní IEncrypter ještì implementuje tøída EncrypterReversibleCA, která realizuje šifrování alternativním zpùsobem (viz poslední kapitola). Nad implementacemi rozhraní IEncrypter je ještì vybudována spoleèná obalová vrstva v podobì tøídy EncryptionProvider. Ta umoòuje šifrovat pøímo Streamy dat a zároveò umoòuje kromì šifrovacího klíèe pouít kombinaci uivatelského hesla a náhodného saltu, co bude pouito v praktické aplikaci.

Statická tøída Export poskytuje pøístup k vìcem, co mají bıt pouitelné i z jiné assembly a provádí veškerou instanciaci interních tøíd, které ji není moné ovládat pøímo z vnìjšku. Napøíklad poskytuje jednu konkrétní implementaci IKeyExtender, do ní je vloen elementární automat èíslo 30 (ve zrychlené variantì). Z vnìjšku není moné vynutit jinou variantu. Dále poskytuje pøístup ke tøídì EncryptionProvider (jsou tu dvì varianty pro dva rùzné vloené šifrovací algoritmy).

\section{Testing}

Nejedná se o ádné Unit testy, ale o pomìrnì chaotickou hromadu metod, které umoòují zkoušet rùzné èásti programu. Lze si hrát s vizualizací nìjakıch automatù.

\section{Program}

Okenní aplikace, umoòuje šifrovat a dešifrovat. V podstatì realizuje jen volbu vstupního a vıstupního souboru. O zbytek se stará projekt MartinDvorak.

\section{CryptographyUnitTests}

Testuje šifrovací algoritmy skrze veøejnou tøídu EncryptionProvider poskytnutou ve dvou verzích tøídou Export.